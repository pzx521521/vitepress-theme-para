<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Protocol Buffers压缩(编码)原理 | Para's</title>
    <meta name="description" content="A VitePress Site">
    <meta name="generator" content="VitePress v1.5.0">
    <link rel="preload stylesheet" href="/assets/style.CH1NDt8c.css" as="style">
    <link rel="preload stylesheet" href="/vp-icons.css" as="style">
    
    <script type="module" src="/assets/app.CkNjWRMl.js"></script>
    <link rel="preload" href="/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/assets/chunks/theme.1-aoGnHK.js">
    <link rel="modulepreload" href="/assets/chunks/framework.DDqBDuc9.js">
    <link rel="modulepreload" href="/assets/posts_golang_ProtocolBuffers_zip.md.CtlEWIe7.lean.js">
    <link rel="icon" href="/logo.svg">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><!--[--><div class="Layout" data-v-54b3b317 data-v-d8b57b2d><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c8291ffa></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c8291ffa> Skip to content </a><!--]--><!----><header class="VPNav" data-v-d8b57b2d data-v-7ad780c2><div class="VPNavBar" data-v-7ad780c2 data-v-9fd4d1dd><div class="wrapper" data-v-9fd4d1dd><div class="container" data-v-9fd4d1dd><div class="title" data-v-9fd4d1dd><div class="VPNavBarTitle" data-v-9fd4d1dd data-v-9f43907a><a class="title" href="/" data-v-9f43907a><!--[--><!--]--><!--[--><img class="VPImage logo" src="/logo.svg" alt data-v-ab19afbb><!--]--><span data-v-9f43907a>Para&#39;s</span><!--[--><!--]--></a></div></div><div class="content" data-v-9fd4d1dd><div class="content-body" data-v-9fd4d1dd><!--[--><!--]--><div class="VPNavBarSearch search" data-v-9fd4d1dd><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-9fd4d1dd data-v-afb2845e><span id="main-nav-aria-label" class="visually-hidden" data-v-afb2845e> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>Home</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/pages/" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>Pages</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/pages/category.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>Category</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/pages/archives.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>Archives</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/pages/tags.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>Tags</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-9fd4d1dd data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-9fd4d1dd data-v-ef6192dc data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/vuejs/vitepress" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-9fd4d1dd data-v-f953d92f data-v-bfe7971f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-bfe7971f><span class="vpi-more-horizontal icon" data-v-bfe7971f></span></button><div class="menu" data-v-bfe7971f><div class="VPMenu" data-v-bfe7971f data-v-20ed86d6><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>Appearance</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/vuejs/vitepress" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-9fd4d1dd data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-9fd4d1dd><div class="divider-line" data-v-9fd4d1dd></div></div></div><!----></header><div class="VPLocalNav empty fixed" data-v-d8b57b2d data-v-2488c25a><div class="container" data-v-2488c25a><!----><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-2488c25a data-v-883964e0><button data-v-883964e0>Return to top</button><!----></div></div></div><!----><div class="VPContent" id="VPContent" data-v-d8b57b2d data-v-9a6c75ad><div class="VPDoc has-aside" data-v-9a6c75ad data-v-e6f2a212><!--[--><!--]--><div class="container" data-v-e6f2a212><div class="aside" data-v-e6f2a212><div class="aside-curtain" data-v-e6f2a212></div><div class="aside-container" data-v-e6f2a212><div class="aside-content" data-v-e6f2a212><div class="VPDocAside" data-v-e6f2a212 data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-f610f197><div class="content" data-v-f610f197><div class="outline-marker" data-v-f610f197></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-f610f197>On this page</div><ul class="VPDocOutlineItem root" data-v-f610f197 data-v-53c99d69><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-e6f2a212><div class="content-container" data-v-e6f2a212><!--[--><!--]--><main class="main" data-v-e6f2a212><div style="position:relative;" class="vp-doc _posts_golang_ProtocolBuffers_zip" data-v-e6f2a212><div><h1 id="编码原网页在这里" tabindex="-1">编码<a href="https://developers.google.cn/protocol-buffers/docs/encoding" target="_blank" rel="noreferrer">原网页在这里</a> <a class="header-anchor" href="#编码原网页在这里" aria-label="Permalink to &quot;编码[原网页在这里](https://developers.google.cn/protocol-buffers/docs/encoding)&quot;">​</a></h1><h2 id="一个简单的消息" tabindex="-1">一个简单的消息 <a class="header-anchor" href="#一个简单的消息" aria-label="Permalink to &quot;一个简单的消息&quot;">​</a></h2><p>假设您有以下非常简单的消息定义：</p><div class="language-proto vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">proto</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">message</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Test1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  optional</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在应用程序中，您创建一条<code>Test1</code>消息并将其设置<code>a</code>为 150。然后将消息序列化为输出流。如果您能够检查编码的消息，您会看到三个Byte：</p><div class="language-proto vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">proto</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">08 96 01</span></span></code></pre></div><p>就3个Byte/ int本身还是4个Byte呢, 为什么是这3个Byte呢? 继续阅读...</p><h2 id="base-128-变种" tabindex="-1">Base 128 变种 <a class="header-anchor" href="#base-128-变种" aria-label="Permalink to &quot;Base 128 变种&quot;">​</a></h2><p>要了解您的简单协议缓冲区编码，您首先需要了解<em>varints</em>。Varints 是一种使用一个或多个字节序列化整数的方法。较小的数字占用较少的字节数。</p><p>varint 中的每个字节，除了最后一个字节，都设置了<strong>最高有效位</strong>(MSB)——这表明还有更多字节要到来。每个字节的低 7 位用于存储以 7 位为一组的数字的二进制补码表示，<strong>最低有效组在前</strong>。</p><p>例如，这里是数字 1——它是一个单字节，所以 MSB 没有设置：</p><div class="language-proto vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">proto</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">0000 0001</span></span></code></pre></div><p>这里是 varint 处理后的300:——这有点复杂：</p><div class="language-proto vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">proto</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">1010 1100 0000 0010</span></span></code></pre></div><p>你怎么知道这是300？首先，您从每个字节中删除 MSB，因为这只是告诉我们是否已经到达数字的末尾（如您所见，它设置在第一个字节中，因为 varint 中有多个字节,</p><p>第一个byte(前8位)的 MSB是1, 所以要往后读</p><p>第二个byte(后8位)的 MSB是0, 所以代表改数字结束了</p><div class="language-proto vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">proto</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 1010 1100 0000 0010</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">→ 010 1100  000 0010</span></span></code></pre></div><p>您必须颠倒两组 7 位(去掉MSB的两个byte)，因为 varint 首先存储具有最低有效组的数字。然后将它们连接起来以获得最终值：</p><div class="language-proto vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">proto</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">000 0010  010 1100</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">→  000 0010 ++ 010 1100</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">→  100101100</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">→  256 + 32 + 8 + 4 = 300</span></span></code></pre></div><h2 id="消息结构" tabindex="-1">消息结构 <a class="header-anchor" href="#消息结构" aria-label="Permalink to &quot;消息结构&quot;">​</a></h2><p>协议缓冲区消息是一系列键值对。消息的二进制版本只是使用字段的编号作为键——每个字段的名称和声明的类型只能在解码端通过引用消息类型的定义（即<code>.proto</code>文件）来确定。</p><p>当消息被编码时，键和值被连接成一个字节流。当消息被解码时，解析器需要能够跳过它无法识别的字段。这样，可以将新字段添加到消息中，而不会破坏不了解它们的旧程序。为此，有线格式消息中每一对的“键”实际上是两个值——<code>.proto</code>文件中的字段编号，加上提供足够信息来查找以下值的长度的*有线类型。*在大多数语言实现中，这个键被称为标签。</p><p>可用的电线类型如下：</p><table tabindex="0"><thead><tr><th style="text-align:left;">类型</th><th style="text-align:left;">意义</th><th style="text-align:left;">用于</th></tr></thead><tbody><tr><td style="text-align:left;">0</td><td style="text-align:left;">Varint</td><td style="text-align:left;">int32, int64, uint32, uint64, sint32, sint64, bool, enum</td></tr><tr><td style="text-align:left;">1</td><td style="text-align:left;">64-bit</td><td style="text-align:left;">fixed64, sfixed64, double</td></tr><tr><td style="text-align:left;">2</td><td style="text-align:left;">Length-delimited</td><td style="text-align:left;">string, bytes, embedded messages, packed repeated fields</td></tr><tr><td style="text-align:left;">3</td><td style="text-align:left;">Start group</td><td style="text-align:left;">groups（已弃用）</td></tr><tr><td style="text-align:left;">4</td><td style="text-align:left;">End group</td><td style="text-align:left;">groups（已弃用）</td></tr><tr><td style="text-align:left;">5</td><td style="text-align:left;">32 位</td><td style="text-align:left;">fixed32, sfixed32, float</td></tr></tbody></table><p>流式消息中的每个键都是带有值的 varint <code>(field_number &lt;&lt; 3) | wire_type</code>- 换句话说，数字的最后三位存储类型。</p><p>现在让我们再次看一下我们的简单示例。您现在知道流中的第一个数字始终是 varint 键，这里是 08，或者（删除 MSB）：</p><div class="language-proto vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">proto</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">000 1000</span></span></code></pre></div><p>您取最后三位来获取类型 (0)，然后右移三位以获取字段编号 (000 1)。所以你现在知道字段号是 1，下面的值是一个 varint。使用上一节中的 varint 解码知识，您可以看到接下来的两个字节存储值 150。</p><div class="language-proto vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">proto</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">96 01 = 1001 0110  0000 0001</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       → 000 0001  ++  001 0110 (drop the MSB and reverse the groups of 7 bits)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       → 10010110</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       → 128 + 16 + 4 + 2 = 150</span></span></code></pre></div><h2 id="更多值类型" tabindex="-1">更多值类型 <a class="header-anchor" href="#更多值类型" aria-label="Permalink to &quot;更多值类型&quot;">​</a></h2><h3 id="有符号整数" tabindex="-1">有符号整数 <a class="header-anchor" href="#有符号整数" aria-label="Permalink to &quot;有符号整数&quot;">​</a></h3><p>正如您在上一节中看到的，与线类型 0 关联的所有协议缓冲区类型都被编码为 varint。但是，在编码负数时，带符号的 int 类型（ <code>sint32</code>and <code>sint64</code>）和“标准” int 类型（<code>int32</code>and ）之间存在重要区别。<code>int64</code>如果使用<code>int32</code>or<code>int64</code>作为负数的类型，则生成的 varint<em>始终为 10 个字节长</em>——实际上，它被视为一个非常大的无符号整数。如果您使用其中一种有符号类型，则生成的 varint 将使用 ZigZag 编码，这种编码效率更高。</p><p>ZigZag 编码将有符号整数映射到无符号整数，因此具有较小<em>绝对值</em>（例如，-1）的数字也具有较小的 varint 编码值。它通过正整数和负整数来回“曲折”来执行此操作，因此 -1 被编码为 1，1 被编码为 2，-2 被编码为 3，依此类推，就像你可以在下表中看到：</p><table tabindex="0"><thead><tr><th style="text-align:left;">签名原件</th><th style="text-align:left;">编码为</th></tr></thead><tbody><tr><td style="text-align:left;">0</td><td style="text-align:left;">0</td></tr><tr><td style="text-align:left;">-1</td><td style="text-align:left;">1</td></tr><tr><td style="text-align:left;">1</td><td style="text-align:left;">2</td></tr><tr><td style="text-align:left;">-2</td><td style="text-align:left;">3</td></tr><tr><td style="text-align:left;">2147483647</td><td style="text-align:left;">4294967294</td></tr><tr><td style="text-align:left;">-2147483648</td><td style="text-align:left;">4294967295</td></tr></tbody></table><p>换句话说，每个值<code>n</code>都使用编码</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(n &lt;&lt; 1) ^ (n &gt;&gt; 31)</span></span></code></pre></div><p>对于<code>sint32</code>s，或</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(n &lt;&lt; 1) ^ (n &gt;&gt; 63)</span></span></code></pre></div><p>对于 64 位版本。</p><p>请注意，第二个移位 -<code>(n &gt;&gt; 31)</code>部分 - 是算术移位。因此，换句话说，移位的结果要么是一个全为零的数字（如果<code>n</code>是正数），要么是全为一的数字（如果<code>n</code>是负数）。</p><p>当<code>sint32</code>or<code>sint64</code>被解析时，它的值被解码回原始的签名版本。</p><h3 id="非-varint-数值" tabindex="-1">非 varint 数值 <a class="header-anchor" href="#非-varint-数值" aria-label="Permalink to &quot;非 varint 数值&quot;">​</a></h3><p>非 varint 数值类型很简单——<code>double</code>并且<code>fixed64</code>具有连线类型 1，它告诉解析器期待一个固定的 64 位数据块；类似地<code>float</code>并且<code>fixed32</code>具有线类型 5，它告诉它期望 32 位。在这两种情况下，值都以 little-endian 字节顺序存储。</p><h3 id="字符串" tabindex="-1">字符串 <a class="header-anchor" href="#字符串" aria-label="Permalink to &quot;字符串&quot;">​</a></h3><p>线路类型 2（长度分隔）表示该值是一个 varint 编码长度，后跟指定的数据字节数。</p><div class="language-proto vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">proto</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">message</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Test2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  optional</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>将 b 的值设置为“testing”可以为您提供：</p><div class="language-proto vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">proto</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">12 07 [74 65 73 74 69 6e 67]</span></span></code></pre></div><p>[括号]中的字节是“testing”的UTF8(实际中没有&quot;]&quot;, 写上只是为了更容易理解)。这里的关键是 0x12。它被解析：</p><div class="language-proto vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">proto</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">0x12</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">→ 0001 0010  (binary representation)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">→ 00010 010  (regroup bits)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">→ field_number = 2, wire_type = 2</span></span></code></pre></div><p>值中的长度 varint 为 7，其后的七个字节是字符串。</p><h2 id="嵌入式消息" tabindex="-1">嵌入式消息 <a class="header-anchor" href="#嵌入式消息" aria-label="Permalink to &quot;嵌入式消息&quot;">​</a></h2><p>这是一个包含我们示例类型 Test1 的嵌入式消息的消息定义：</p><div class="language-proto vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">proto</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">message</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Test3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  optional</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Test1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这是编码版本，Test1 的<code>a</code>字段再次设置为 150：</p><div class="language-proto vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">proto</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 1a 03 08 96 01</span></span></code></pre></div><p>如您所见，最后三个字节与我们的第一个示例 ( ) 完全相同<code>08 96 01</code>，并且它们前面是数字 03(即长度)</p><p>嵌入消息的处理方式与字符串完全相同（wire type = 2）。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>0x1a</span></span>
<span class="line"><span>→ 0001 1010  (binary representation)</span></span>
<span class="line"><span>→ 00011 010  (regroup bits)</span></span>
<span class="line"><span>→ field_number = 3, wire_type = 2</span></span></code></pre></div><h2 id="可选元素和重复元素" tabindex="-1">可选元素和重复元素 <a class="header-anchor" href="#可选元素和重复元素" aria-label="Permalink to &quot;可选元素和重复元素&quot;">​</a></h2><p>如果 proto2 消息定义包含<code>repeated</code>元素（没有<code>[packed=true]</code>选项），则编码消息具有零个或多个具有相同字段编号的键值对。这些重复值不必连续出现；它们可能与其他字段交错。解析时会保留元素相对于彼此的顺序，尽管相对于其他字段的顺序会丢失。在 proto3 中，重复字段使用<a href="https://developers.google.cn/protocol-buffers/docs/encoding#packed" target="_blank" rel="noreferrer">打包编码</a>，您可以在下面阅读。</p><p>对于 proto3 中的任何非重复字段或<code>optional</code>proto2 中的字段，编码的消息可能具有也可能没有具有该字段编号的键值对。</p><p>通常，编码消息永远不会有多个非重复字段的实例。但是，解析器应该处理它们所做的情况。对于数字类型和字符串，如果同一个字段出现多次，解析器接受它看到的*最后一个值。*对于嵌入的消息字段，解析器合并同一字段的多个实例，就像使用<code>Message::MergeFrom</code>方法一样——即后一个实例中的所有奇异标量字段替换前者，合并单个嵌入消息，并连接重复的字段。这些规则的效果是解析两个编码消息的连接会产生完全相同的结果，就像您分别解析两个消息并合并结果对象一样。也就是说，这个：</p><div class="language-proto vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">proto</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MyMessage message;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">message.ParseFromString(str1 + str2);</span></span></code></pre></div><p>相当于：</p><div class="language-proto vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">proto</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MyMessage message, message2;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">message.ParseFromString(str1);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">message2.ParseFromString(str2);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">message.MergeFrom(message2);</span></span></code></pre></div><p>此属性有时很有用，因为它允许您合并两条消息，即使您不知道它们的类型。</p><h3 id="打包的重复字段" tabindex="-1">打包的重复字段 <a class="header-anchor" href="#打包的重复字段" aria-label="Permalink to &quot;打包的重复字段&quot;">​</a></h3><p>2.1.0 版引入了打包的重复字段，在 proto2 中被声明为重复字段，但带有特殊<code>[packed=true]</code>选项。在 proto3 中，默认情况下会打包标量数字类型的重复字段。这些功能类似于重复字段，但编码不同。包含零个元素的压缩重复字段不会出现在编码消息中。否则，该字段的所有元素都被打包成一个带有线类型 2（长度分隔）的键值对。每个元素的编码方式与正常情况相同，只是前面没有键。</p><p>例如，假设您有消息类型：</p><div class="language-proto vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">proto</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">message</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Test4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  repeated</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">packed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>现在假设您构造 a <code>Test4</code>，为重复字段提供值 3、270 和 86942 <code>d</code>。然后，编码形式将是：</p><div class="language-proto vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">proto</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">22        </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// key (field number 4, wire type 2)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">06        </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// payload size (6 bytes)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">03        </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// first element (varint 3)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">8E 02     </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// second element (varint 270)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">9E A7 05  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// third element (varint 86942)</span></span></code></pre></div><p>只有原始数字类型（使用 varint、32 位或 64 位连线类型的类型）的重复字段才能被声明为“打包”。</p><p>请注意，尽管通常没有理由为打包的重复字段编码多个键值对，但解析器必须准备好接受多个键值对。在这种情况下，应连接有效载荷。每对必须包含整数个元素。</p><p>协议缓冲区解析器必须能够解析被编译的重复字段，就<code>packed</code>好像它们没有被打包一样，反之亦然。这允许<code>[packed=true]</code>以向前和向后兼容的方式添加到现有字段。</p><h2 id="现场顺序" tabindex="-1">现场顺序 <a class="header-anchor" href="#现场顺序" aria-label="Permalink to &quot;现场顺序&quot;">​</a></h2><p>字段编号可以在<code>.proto</code>文件中以任何顺序使用。选择的顺序对消息的序列化方式没有影响。</p><p><a href="https://developers.google.cn/protocol-buffers/docs/proto#updating" target="_blank" rel="noreferrer">当消息被序列化时，其已知或未知字段</a>的写入方式没有保证的顺序。序列化顺序是一个实现细节，任何特定实现的细节都可能在未来发生变化。因此，协议缓冲区解析器必须能够以任何顺序解析字段。</p><h3 id="影响" tabindex="-1">影响 <a class="header-anchor" href="#影响" aria-label="Permalink to &quot;影响&quot;">​</a></h3><ul><li><p>不要假设序列化消息的字节输出是稳定的。对于具有表示其他序列化协议缓冲区消息的传递字节字段的消息尤其如此。</p></li><li><p>默认情况下，在同一协议缓冲区消息实例上重复调用序列化方法可能不会产生相同的字节输出。也就是说，默认序列化不是确定性的。</p><ul><li>确定性序列化仅保证特定二进制文件的相同字节输出。字节输出可能会在不同版本的二进制文件中发生变化。</li></ul></li><li><p>对于协议缓冲区消息实例，以下检查可能会失败</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>foo</span></span></code></pre></div><p>：</p><ul><li><code>foo.SerializeAsString() == foo.SerializeAsString()</code></li><li><code>Hash(foo.SerializeAsString()) == Hash(foo.SerializeAsString())</code></li><li><code>CRC(foo.SerializeAsString()) == CRC(foo.SerializeAsString())</code></li><li><code>FingerPrint(foo.SerializeAsString()) == FingerPrint(foo.SerializeAsString())</code></li></ul></li><li><p>以下是一些逻辑上等效的协议缓冲区消息的示例场景，</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>foo</span></span></code></pre></div><p>并且</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>bar</span></span></code></pre></div><p>可能会序列化为不同的字节输出：</p><ul><li><code>bar</code>由将某些字段视为未知的旧服务器序列化。</li><li><code>bar</code>由以不同编程语言实现并以不同顺序序列化字段的服务器进行序列化。</li><li><code>bar</code>具有以非确定性方式序列化的字段。</li><li><code>bar</code>有一个字段存储协议缓冲区消息的序列化字节输出，该消息以不同的方式序列化。</li><li><code>bar</code>由一个新服务器序列化，该服务器由于实现更改而以不同的顺序序列化字段。</li><li><code>foo</code>并且<code>bar</code>是相同的单个消息以不同顺序的串联。</li></ul></li></ul><h2 id="精简参考卡" tabindex="-1">精简参考卡 <a class="header-anchor" href="#精简参考卡" aria-label="Permalink to &quot;精简参考卡&quot;">​</a></h2><p>以下以易于参考的格式提供了线路格式中最突出的部分。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>message   := (tag value)*     You can think of this as “key value”</span></span>
<span class="line"><span></span></span>
<span class="line"><span>tag       := (field &lt;&lt; 3) BIT_OR wire_type, encoded as varint</span></span>
<span class="line"><span>value     := (varint|zigzag) for wire_type==0 |</span></span>
<span class="line"><span>             fixed32bit      for wire_type==5 |</span></span>
<span class="line"><span>             fixed64bit      for wire_type==1 |</span></span>
<span class="line"><span>             delimited       for wire_type==2 |</span></span>
<span class="line"><span>             group_start     for wire_type==3 | This is like “open parenthesis”</span></span>
<span class="line"><span>             group_end       for wire_type==4   This is like “close parenthesis”</span></span>
<span class="line"><span></span></span>
<span class="line"><span>varint       := int32 | int64 | uint32 | uint64 | bool | enum, encoded as</span></span>
<span class="line"><span>                varints</span></span>
<span class="line"><span>zigzag       := sint32 | sint64, encoded as zig-zag varints</span></span>
<span class="line"><span>fixed32bit   := sfixed32 | fixed32 | float, encoded as 4-byte little-endian;</span></span>
<span class="line"><span>                memcpy of the equivalent C types (u?int32_t, float)</span></span>
<span class="line"><span>fixed64bit   := sfixed64 | fixed64 | double, encoded as 8-byte little-endian;</span></span>
<span class="line"><span>                memcpy of the equivalent C types (u?int64_t, double)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>delimited := size (message | string | bytes | packed), size encoded as varint</span></span>
<span class="line"><span>message   := valid protobuf sub-message</span></span>
<span class="line"><span>string    := valid UTF-8 string (often simply ASCII); max 2GB of bytes</span></span>
<span class="line"><span>bytes     := any sequence of 8-bit bytes; max 2GB</span></span>
<span class="line"><span>packed    := varint* | fixed32bit* | fixed64bit*,</span></span>
<span class="line"><span>             consecutive values of the type described in the protocol definition</span></span>
<span class="line"><span></span></span>
<span class="line"><span>varint encoding: sets MSB of byte to 1 to indicate that there are more bytes</span></span>
<span class="line"><span>zigzag encoding: sint32 and sint64 types use zigzag encoding.</span></span></code></pre></div><h3 id="钥匙" tabindex="-1">钥匙 <a class="header-anchor" href="#钥匙" aria-label="Permalink to &quot;钥匙&quot;">​</a></h3><ul><li><p><code>message := (tag value)*</code></p><p>消息被编码为零个或多个标签和值对的序列。</p></li><li><p><code>tag := (field &lt;&lt; 3) BIT_OR wire_type, encoded as varint</code></p><p>标记是<code>wire_type</code>存储在最低有效三位中的 a 和<code>.proto</code>文件中定义的字段编号的组合。</p></li><li><p><code>value := varint for wire_type==0, fixed32 for wire_type==5, ...</code></p><p><code>wire_type</code>根据标签中的指定，值的存储方式不同。</p></li><li><p><code>varint := int32 | int64 | uint32 | uint64 | sint32 | sint64 | bool | enum</code></p><p>您可以使用 varint 存储任何列出的数据类型。</p></li><li><p><code>fixed32 := int32 | uint32 | float</code></p><p>您可以使用 fixed32 来存储任何列出的数据类型。</p></li><li><p><code>fixed64 := int64 | uint64 | double</code></p><p>您可以使用 fixed64 存储任何列出的数据类型。</p></li><li><p><code>delimited := size (message | string | bytes | packed)</code></p><p>分隔值存储为大小，编码为 varint，然后是列出的数据类型之一。</p></li><li><p><code>message := valid protobuf sub-message</code></p><p>消息数据类型存储一条消息，然后可以将其存储在另一条消息中。</p></li><li><p><code>string := valid UTF-8 string, or sequence of 7-bit ASCII bytes; max 2GB</code></p><p>如前所述，字符串必须使用 UTF-8 字符编码。一个字符串不能超过 2GB。</p></li><li><p><code>bytes := any sequence of 8-bit bytes; max 2GB</code></p><p>如上所述，字节可以存储自定义数据类型，最大为 2GB。</p></li><li><p><code>packed := varint* | fixed32* | fixed64*</code></p><p><code>packed</code>当您存储协议定义中描述的类型的连续值时，请使用数据类型。标记在第一个之后的值被丢弃，这提高了协议缓冲区的效率。</p></li><li><p><code>varint encoding: sets MSB of byte to 1 to indicate that there are more bytes</code></p><p>有关如何序列化 varint 的更多信息，请参阅前面的部分<a href="https://developers.google.cn/protocol-buffers/docs/encoding#varints" target="_blank" rel="noreferrer">Base 128 Varints 。</a></p></li><li><p><code>zigzag encoding: sint32 and sint64 types use zigzag encoding</code></p><p><code>sint32</code>和类型使用 zigzag 编码，以便用小序列<code>sint64</code>表示小的负数。<code>varint</code>有关 zigzag 编码的更多信息，请参阅前面的有<a href="https://developers.google.cn/protocol-buffers/docs/encoding#signed-ints" target="_blank" rel="noreferrer">符号整数</a>部分。</p></li></ul><p>除非另有说明，本页内容均采用<a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noreferrer">Creative Commons Attribution 4.0 License 许可</a>，代码示例采用<a href="https://www.apache.org/licenses/LICENSE-2.0" target="_blank" rel="noreferrer">Apache 2.0 License 许可</a>。有关详细信息，请参阅<a href="https://developers.google.cn/site-policies" target="_blank" rel="noreferrer">Google Developers 网站政策</a>。Java 是 Oracle 和/或其附属公司的注册商标。</p><p>最后更新时间为 2022-05-25 UTC。</p></div></div></main><footer class="VPDocFooter" data-v-e6f2a212 data-v-1bcd8184><!--[--><!--]--><!----><!----></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div><div class="site-footer footer" data-v-54b3b317> Powered by <a class="vitepress" target="_blank" href="//vitepress.vuejs.org/">VitePress - 1.4.1</a></div><!--]--></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"C1ckV9Il\",\"pages_archives.md\":\"B21fPNtb\",\"pages_category.md\":\"CBur-Ef8\",\"pages_index.md\":\"DI7wwlS9\",\"pages_tags.md\":\"BZILGPlp\",\"posts_golang_expvar.md\":\"86Ki9be5\",\"posts_golang_go-http.md\":\"BbnuumkP\",\"posts_golang_go私有仓库.md\":\"CJjQoVcg\",\"posts_golang_grpcgetway.md\":\"zRSVqGex\",\"posts_golang_jaeger.md\":\"CjECfTEH\",\"posts_golang_kafka.md\":\"BRU9kqcH\",\"posts_golang_protocolbuffers_zip.md\":\"CtlEWIe7\",\"posts_golang_simple_http_golang.md\":\"DjHiM6Sf\",\"posts_golang_wg导致的提前返回.md\":\"yNOn7TOY\",\"posts_golang_用hysteria2做ip池.md\":\"wliG7mnn\",\"posts_linux_netdata.md\":\"B0Ij-SwE\",\"posts_linux_nginx_limit.md\":\"DUbu0hRT\",\"posts_linux_nginx_ssi.md\":\"TWevfjp-\",\"posts_linux_nsq.md\":\"DDnpcXj_\",\"posts_linux_redis_run_docker.md\":\"DzdcuFvi\",\"posts_linux_sshadd.md\":\"JvvPNmcB\",\"posts_linux_云原生的前世今生_k8s.md\":\"Crzkj_yt\",\"posts_linux_云原生的前世今生_云原生.md\":\"CY1kzk9m\",\"posts_linux_云原生的前世今生_云原生的前世今生.md\":\"BjB-CZeq\",\"posts_linux_云原生的前世今生_云造价实现方案.md\":\"lP7y24hX\",\"posts_linux_跨平台编译基础.md\":\"Bz-C1iwy\",\"posts_python_python_math.md\":\"C3C8Xdqr\",\"posts_windows_innosetup.md\":\"Cpl0l_2N\",\"posts_单片机_mcu_esp8266-nodemcu.md\":\"JY5dHZji\",\"posts_单片机_mcu_esp8266_cp340.md\":\"CEAsZ8vP\",\"posts_单片机_mcu_wifi_killer.md\":\"UXrVFAWS\",\"posts_单片机_mcu_wokwi-uno.md\":\"WalXErp3\",\"posts_单片机_tcp46.md\":\"DVL5OUvg\",\"posts_单片机_xiaomi_openwrt.md\":\"B8DGySzr\",\"posts_单片机_xiaomi_rathole.md\":\"nQ-kce_4\",\"posts_密码_专利.md\":\"QS4T-heL\",\"posts_杂记_github-desktop使用clash代理验证失败的问题.md\":\"CL3isPad\",\"posts_杂记_pad.md\":\"DJUx6NNV\",\"posts_杂记_testflow.md\":\"BZIAfp5g\",\"posts_杂记_tor介绍.md\":\"j3YLfyip\",\"posts_运维_ci脚本_ci脚本说明.md\":\"DFfXVJBZ\",\"posts_运维_gossip.md\":\"T_2L6Abn\",\"posts_运维_mqtt.md\":\"A5xwwrwe\",\"posts_运维_prometheus_grafana.md\":\"DQOPpQD_\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"Para's\",\"description\":\"A VitePress Site\",\"base\":\"/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"pageSize\":10,\"posts\":[{\"frontMatter\":{\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":273,\"tags\":[\"运维\"],\"category\":\"运维\",\"title\":\"prometheus&grafana\"},\"regularPath\":\"/posts/运维/prometheus&grafana.html\"},{\"frontMatter\":{\"title\":\"\\\"MQTT入门\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":7722,\"tags\":[\"运维\"],\"category\":\"运维\",\"description\":\"\"},\"regularPath\":\"/posts/运维/mqtt.html\"},{\"frontMatter\":{\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":6011,\"tags\":[\"运维\"],\"category\":\"运维\",\"title\":\"gossip\",\"description\":\"Gossip协议是一个通信协议，一种传播消息的方式，灵感来自于：瘟疫、社交网络等。使用Gossip协议的有：Redis Cluster、Consul、Apache Cassandra等。\"},\"regularPath\":\"/posts/运维/gossip.html\"},{\"frontMatter\":{\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":1407,\"tags\":[\"运维\",\"CI脚本\"],\"category\":\"CI脚本\",\"title\":\"CI脚本说明\",\"description\":\"持续集成Continuous Integration(CI)()和持续交付Continuous Delivery(CD)\\n\\nCI :代码->svn exe (自动构建exe到测试环境)\\n\\nCD: svn exe->用户  (测试环境到自动发版)\\n\\nCI/CD流程体验:[github action](https://github.com/marketplace?type=actions)\\n\\ngithub action实现原理是[云原生](.\\\\云原生的前世今生\\\\云原生的前世今生.md)\"},\"regularPath\":\"/posts/运维/CI脚本/CI脚本说明.html\"},{\"frontMatter\":{\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":494,\"tags\":[\"杂记\"],\"category\":\"杂记\",\"title\":\"tor介绍\",\"description\":\"\"},\"regularPath\":\"/posts/杂记/tor介绍.html\"},{\"frontMatter\":{\"title\":\"\\\"记一次阿里code-flow(云效)git pull出现的问题\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":1807,\"tags\":[\"杂记\"],\"category\":\"杂记\",\"description\":\"git pull 本地可以 但是通过阿里flow 不可以\"},\"regularPath\":\"/posts/杂记/testflow.html\"},{\"frontMatter\":{\"title\":\"\\\"笔记本推荐\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":5077,\"tags\":[\"杂记\"],\"category\":\"杂记\",\"description\":\"\"},\"regularPath\":\"/posts/杂记/pad.html\"},{\"frontMatter\":{\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":1603,\"tags\":[\"杂记\"],\"category\":\"杂记\",\"title\":\"github-desktop使用clash代理验证失败的问题\",\"description\":\"使用git命令上传会出现:`Warning: the ECDSA host key for 'github.com' differs from the key for the IP address '198.18.0.8'`\\n\\n出现这个警告是因为 SSH 客户端发现 `github.com` 的 ECDSA 主机密钥与 `198.18.0.8` 的密钥不同。可能的原因包括：\\n\\n1. **DNS 劫持或攻击**：如果你连接的是假的 GitHub 服务器，SSH 会警告密钥不匹配。\\n2. **代理或 VPN 设置**：某些网络代理或 VPN 可能会导致连接 IP 地址的变更，进而导致密钥不一致。\\n3. **GitHub IP 地址变化**：在 GitHub 的 IP 地址改变后，本地 SSH 客户端可能会认为新的 IP 地址不是以前的主机密钥，显示此警告。\"},\"regularPath\":\"/posts/杂记/github-desktop使用clash代理验证失败的问题.html\"},{\"frontMatter\":{\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":7613,\"tags\":[\"密码\"],\"category\":\"密码\",\"title\":\"专利\",\"description\":\"**技术领域**\\n\\n人工智能和工程造价的(自动匹配单价引用)组合应用\\n\\n**背景技术**\\n\\n+ 数据的清洗整理和Onehot处理\\n+ LogisticRegression(逻辑回归)\\n\\n**发明内容**\\n\\n用户户在导入工程之后,需手动对清单定额进行单价引用以达到多条清单同步价格的目的,该技术可以部分代替用户输入,自动对多条清单的同步单价关系自动关联\\n\\n**附图**\\n\\n\\n\\n**具体实施方式**\"},\"regularPath\":\"/posts/密码/专利.html\"},{\"frontMatter\":{\"title\":\"\\\"小米4a 内网穿透\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":1232,\"tags\":[\"单片机\"],\"category\":\"单片机\",\"description\":\"\"},\"regularPath\":\"/posts/单片机/xiaomi_rathole.html\"},{\"frontMatter\":{\"title\":\"\\\"小米4a刷openert\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":2988,\"tags\":[\"单片机\"],\"category\":\"单片机\",\"description\":\"网上教程乱七八糟的, 这里整理一下, 最新的[这个](https://www.luyouwang.net/9751.html)能用\\n\\n[官网在这里](https://openwrt.org/inbox/toh/xiaomi/r4ac?s[]=xiaomi&s[]=4a)\\n\\n注意4a百兆 和千兆的刷的包是不一样的\"},\"regularPath\":\"/posts/单片机/xiaomi_openwrt.html\"},{\"frontMatter\":{\"title\":\"\\\"golang tcp6 网无法访问\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":2373,\"tags\":[\"单片机\"],\"category\":\"单片机\",\"description\":\"\"},\"regularPath\":\"/posts/单片机/tcp46.html\"},{\"frontMatter\":{\"title\":\"\\\"上拉电阻和下拉电阻的模拟\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":1745,\"tags\":[\"单片机\",\"MCU\"],\"category\":\"MCU\",\"description\":\"因为引用了github里面的asm, 所以github必须通, 可以翻墙/其他方法 解决\\n\\n看控制台就知道了\"},\"regularPath\":\"/posts/单片机/MCU/wokwi-UNO.html\"},{\"frontMatter\":{\"title\":\"\\\"wifi kill 是如何工作的\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":1966,\"tags\":[\"单片机\",\"MCU\"],\"category\":\"MCU\",\"description\":\"[官方源码在这里](https://github.com/spacehuhntech/esp8266_deauther/)\\n\\n云盘: https://wwu.lanzouy.com/i83vl0aiducj\\n\\n提供了bin 和 Arduino 两种安装方式\\n\\n总而言之就是利用wifi协议的漏洞, wifi提供方是大爷,所以协议没有对wifi提供方做太多限制\"},\"regularPath\":\"/posts/单片机/MCU/Wifi_killer.html\"},{\"frontMatter\":{\"title\":\"\\\"ESP8266开发板的使用\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":11449,\"tags\":[\"单片机\",\"MCU\"],\"category\":\"MCU\",\"description\":\"**纯新手程序员**, 想体验一下物联网,打算做一个联网控制的开关.\\n\\n搜了一下最便宜的就是ESP8226,教程也多.\\n\\n有服务器,打算自己搭建MQTT(by RabiitMQ)来控制, 不好搞就http/tcp来控制\\n\\n用游戏引擎Godot开发跨平台程序, 不好搞就android原生开发或者网页开发\\n\\n下面是单片机相关的开发的学习过程\"},\"regularPath\":\"/posts/单片机/MCU/ESP8266_CP340.html\"},{\"frontMatter\":{\"title\":\"\\\"ESP8266-NodeMCU\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":24377,\"tags\":[\"单片机\",\"MCU\"],\"category\":\"MCU\",\"description\":\"我是小白,对智能家居很感兴趣,之前wifi/物联网太贵了,学习成本太高了.发现ESP8266太便宜了,还带wifi.想用ESP8266做一个简单的智能插座.基本就是整个学习过程\"},\"regularPath\":\"/posts/单片机/MCU/ESP8266-NodeMCU.html\"},{\"frontMatter\":{\"title\":\"\\\"python sympy 解方程\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":856,\"tags\":[\"python\"],\"category\":\"python\"},\"regularPath\":\"/posts/python/python_math.html\"},{\"frontMatter\":{\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":7620,\"tags\":[\"golang\"],\"category\":\"golang\",\"title\":\"用hysteria2做ip池\",\"description\":\"+ 起因爬虫做了ip的并发限制，大量爬取之后ip被封，所以想用hysteria2做ip池.\\n+ 为什么用hysteria2也是因为目前来看hysteria2用的比ss多\\n+ hysteria2/clash/ss 这些本身编译好的程序都是不支持 访问同一个网站的时候使用不同ip的.唯一方案是开启多个客户端,但是很麻烦.\\n+ ip池本身使用的是clash的配置文件\\n+ 这种pr官方肯定不会接受... 放一下魔改了的源码\"},\"regularPath\":\"/posts/golang/用hysteria2做ip池.html\"},{\"frontMatter\":{\"title\":\"\\\"wg导致的提前返回\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":1794,\"tags\":[\"golang\"],\"category\":\"golang\",\"description\":\"#### 逻辑描述: \\n\\n给定一个int数组, 返回一个map, 该map包含该数组及对该数组数字的处理\"},\"regularPath\":\"/posts/golang/wg导致的提前返回.html\"},{\"frontMatter\":{\"title\":\"\\\"golang http demo\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":844,\"tags\":[\"golang\"],\"category\":\"golang\"},\"regularPath\":\"/posts/golang/simple_http_golang.html\"},{\"frontMatter\":{\"title\":\"\\\"Kafka入门\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":6555,\"tags\":[\"golang\"],\"category\":\"golang\",\"description\":\"\"},\"regularPath\":\"/posts/golang/kafka.html\"},{\"frontMatter\":{\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":1100,\"tags\":[\"golang\"],\"category\":\"golang\",\"title\":\"jaeger\"},\"regularPath\":\"/posts/golang/jaeger.html\"},{\"frontMatter\":{\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":512,\"tags\":[\"golang\"],\"category\":\"golang\",\"title\":\"grpcgetway\"},\"regularPath\":\"/posts/golang/grpcgetway.html\"},{\"frontMatter\":{\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":203,\"tags\":[\"golang\"],\"category\":\"golang\",\"title\":\"go私有仓库\"},\"regularPath\":\"/posts/golang/go私有仓库.html\"},{\"frontMatter\":{\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":1618,\"tags\":[\"golang\"],\"category\":\"golang\",\"title\":\"go-http\"},\"regularPath\":\"/posts/golang/go-http.html\"},{\"frontMatter\":{\"title\":\"\\\"expvar 简单使用\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":1283,\"tags\":[\"golang\"],\"category\":\"golang\",\"description\":\"> Package expvar provides a standardized interface to public variables, such as operation counters in servers. It exposes these variables via HTTP at **/debug/vars** in JSON format.\\n\\n> In addition to adding the HTTP handler, this package registers the following variables:\\n\\n```\\ncmdline   os.Args\\nmemstats  runtime.Memstats\\n```\\n\\n> The package is sometimes only imported for the side effect of registering its HTTP handler and the above variables. To use it this way, link this package into your program:\\n\\n导入包就是使用了, 会自动添加一个**/debug/vars**的http 服务, 具体实现看源码, 很简单, \\n\\n有一个多线程 map读写锁的实现\\n\\n```\\nimport _ \\\"expvar\\\"\\n```\"},\"regularPath\":\"/posts/golang/expvar.html\"},{\"frontMatter\":{\"title\":\"\\\"Protocol Buffers压缩(编码)原理\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":16689,\"tags\":[\"golang\"],\"category\":\"golang\",\"description\":\"\"},\"regularPath\":\"/posts/golang/ProtocolBuffers_zip.html\"},{\"frontMatter\":{\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":2314,\"tags\":[\"Windows\"],\"category\":\"Windows\",\"title\":\"innosetup\",\"description\":\"\"},\"regularPath\":\"/posts/Windows/innosetup.html\"},{\"frontMatter\":{\"title\":\"\\\"跨平台编译基础\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":20933,\"tags\":[\"Linux\"],\"category\":\"Linux\",\"description\":\"\"},\"regularPath\":\"/posts/Linux/跨平台编译基础.html\"},{\"frontMatter\":{\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":455,\"tags\":[\"Linux\",\"云原生的前世今生\"],\"category\":\"云原生的前世今生\",\"title\":\"云造价实现方案\",\"description\":\"由于用户数量的不确定性 一台服务器不一定够用, 采用云原生的方式构建, 方便上云和重新构建\"},\"regularPath\":\"/posts/Linux/云原生的前世今生/云造价实现方案.html\"},{\"frontMatter\":{\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":4147,\"tags\":[\"Linux\",\"云原生的前世今生\"],\"category\":\"云原生的前世今生\",\"title\":\"云原生的前世今生\",\"description\":\"![](img\\\\微服务.webp)\\n\\n![](img\\\\微服务2.webp)\"},\"regularPath\":\"/posts/Linux/云原生的前世今生/云原生的前世今生.html\"},{\"frontMatter\":{\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":6255,\"tags\":[\"Linux\",\"云原生的前世今生\"],\"category\":\"云原生的前世今生\",\"title\":\"云原生\",\"description\":\"xshell \\n\\n~~ftp~~~\\n\\nsftp\"},\"regularPath\":\"/posts/Linux/云原生的前世今生/云原生.html\"},{\"frontMatter\":{\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":2407,\"tags\":[\"Linux\",\"云原生的前世今生\"],\"category\":\"云原生的前世今生\",\"title\":\"k8s\",\"description\":\"\"},\"regularPath\":\"/posts/Linux/云原生的前世今生/k8s.html\"},{\"frontMatter\":{\"title\":\"\\\"git 免密登录\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":853,\"tags\":[\"Linux\"],\"category\":\"Linux\",\"description\":\"git 分为2种模式:\\n\\nssh 形如: git@codeup.aliyun.com:para/hugo.git\\n\\nhttps 形如: https://codeup.aliyun.com/para/hugo.git\"},\"regularPath\":\"/posts/Linux/sshadd.html\"},{\"frontMatter\":{\"title\":\"\\\"redis 在docker中慢的原因分析\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":5916,\"tags\":[\"Linux\"],\"category\":\"Linux\",\"description\":\"本来想实际测试一下mysql和redis到底差了多少, 按10w次, 发现mysql 用了18s,  redis 用了15s,这不合理啊, 分析下原因, 确定是docker下跑redis的原因\\n\\n[和这个问题是一样的](https://stackoverflow.com/questions/21691540/how-to-optimize-performance-for-a-docker-container)\"},\"regularPath\":\"/posts/Linux/redis_run_docker.html\"},{\"frontMatter\":{\"title\":\"\\\"nginx ssi入门\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":622,\"tags\":[\"Linux\"],\"category\":\"Linux\",\"description\":\"修改nginx.conf\\n\\n```\\n        location /ssi {\\n\\t\\t\\tssi on;\\n\\t\\t\\tssi_silent_errors on;\\n\\t\\t\\tssi_types text/shtml;\\n\\t\\t\\troot   html;\\n        }\\t\\n```\\n\\n添加 `html/ssi/ssi.html`\\n```\\n<!--#include file=\\\"header.html\\\"-->\\n<div> this is content by ssi </div>\\n<!--#include file=\\\"footer.html\\\"-->\\n```\\n添加 `html/ssi/header.html`\\n```\\n<div>this is header</div>\\n```\\n添加 `html/ssi/footer.html`\\n```\\n<div>this is footer</div>\\n```\"},\"regularPath\":\"/posts/Linux/nginx_ssi.html\"},{\"frontMatter\":{\"title\":\"\\\"Nginx 限流\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":11665,\"tags\":[\"Linux\"],\"category\":\"Linux\",\"description\":\"\"},\"regularPath\":\"/posts/Linux/nginx_limit.html\"},{\"frontMatter\":{\"title\":\"\\\"netdata\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":491,\"tags\":[\"Linux\"],\"category\":\"Linux\"},\"regularPath\":\"/posts/Linux/netdata.html\"},{\"frontMatter\":{\"title\":\"\\\"NSQ入门\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-11-10\",\"modify\":\"2024-11-10\",\"size\":3326,\"tags\":[\"Linux\"],\"category\":\"Linux\",\"description\":\"1. 解耦，将一个流程加入一层数据接口拆分成两个部分，上游专注通知，下游专注处理\\n2. 缓冲，应对流量的突然上涨变更，消息队列有很好的缓冲削峰作用\\n3. 异步，上游发送消息以后可以马上返回，处理工作交给下游进行\\n4. 广播，让一个消息被多个下游进行处理\\n5. 冗余，保存处理的消息，防止消息处理失败导致的数据丢失\"},\"regularPath\":\"/posts/Linux/NSQ.html\"}],\"logo\":\"/logo.svg\",\"nav\":[{\"text\":\"Home\",\"link\":\"/\"},{\"text\":\"Pages\",\"link\":\"/pages/\"},{\"text\":\"Category\",\"link\":\"/pages/category\"},{\"text\":\"Archives\",\"link\":\"/pages/archives\"},{\"text\":\"Tags\",\"link\":\"/pages/tags\"}],\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/vuejs/vitepress\"}],\"search\":{\"provider\":\"local\"}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>