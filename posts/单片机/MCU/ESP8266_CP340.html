<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>ESP8266开发板的使用 | Para's</title>
    <meta name="description" content="A VitePress Site">
    <meta name="generator" content="VitePress v1.5.0">
    <link rel="preload stylesheet" href="/assets/style.9AU-fkW2.css" as="style">
    <link rel="preload stylesheet" href="/vp-icons.css" as="style">
    
    <script type="module" src="/assets/app.0Cz_wRh2.js"></script>
    <link rel="preload" href="/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/assets/chunks/theme.BE6HuIKF.js">
    <link rel="modulepreload" href="/assets/chunks/framework.D_NaTb9t.js">
    <link rel="modulepreload" href="/assets/posts_单片机_MCU_ESP8266_CP340.md.Cgbo4t1u.lean.js">
    <link rel="icon" href="/logo.svg">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><!--[--><div class="Layout" data-v-54b3b317 data-v-d8b57b2d><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c8291ffa></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c8291ffa> Skip to content </a><!--]--><!----><header class="VPNav" data-v-d8b57b2d data-v-7ad780c2><div class="VPNavBar" data-v-7ad780c2 data-v-9fd4d1dd><div class="wrapper" data-v-9fd4d1dd><div class="container" data-v-9fd4d1dd><div class="title" data-v-9fd4d1dd><div class="VPNavBarTitle" data-v-9fd4d1dd data-v-9f43907a><a class="title" href="/" data-v-9f43907a><!--[--><!--]--><!--[--><img class="VPImage logo" src="/logo.svg" alt data-v-ab19afbb><!--]--><span data-v-9f43907a>Para&#39;s</span><!--[--><!--]--></a></div></div><div class="content" data-v-9fd4d1dd><div class="content-body" data-v-9fd4d1dd><!--[--><!--]--><div class="VPNavBarSearch search" data-v-9fd4d1dd><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-9fd4d1dd data-v-afb2845e><span id="main-nav-aria-label" class="visually-hidden" data-v-afb2845e> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>Home</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/pages/" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>Pages</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/pages/category.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>Category</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/pages/archives.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>Archives</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/pages/tags.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>Tags</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-9fd4d1dd data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-9fd4d1dd data-v-ef6192dc data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/vuejs/vitepress" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-9fd4d1dd data-v-f953d92f data-v-bfe7971f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-bfe7971f><span class="vpi-more-horizontal icon" data-v-bfe7971f></span></button><div class="menu" data-v-bfe7971f><div class="VPMenu" data-v-bfe7971f data-v-20ed86d6><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>Appearance</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/vuejs/vitepress" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-9fd4d1dd data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-9fd4d1dd><div class="divider-line" data-v-9fd4d1dd></div></div></div><!----></header><div class="VPLocalNav empty fixed" data-v-d8b57b2d data-v-2488c25a><div class="container" data-v-2488c25a><!----><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-2488c25a data-v-883964e0><button data-v-883964e0>Return to top</button><!----></div></div></div><!----><div class="VPContent" id="VPContent" data-v-d8b57b2d data-v-9a6c75ad><div class="VPDoc has-aside" data-v-9a6c75ad data-v-e6f2a212><!--[--><!--]--><div class="container" data-v-e6f2a212><div class="aside" data-v-e6f2a212><div class="aside-curtain" data-v-e6f2a212></div><div class="aside-container" data-v-e6f2a212><div class="aside-content" data-v-e6f2a212><div class="VPDocAside" data-v-e6f2a212 data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-f610f197><div class="content" data-v-f610f197><div class="outline-marker" data-v-f610f197></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-f610f197>On this page</div><ul class="VPDocOutlineItem root" data-v-f610f197 data-v-53c99d69><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-e6f2a212><div class="content-container" data-v-e6f2a212><!--[--><!--]--><main class="main" data-v-e6f2a212><div style="position:relative;" class="vp-doc _posts_%E5%8D%95%E7%89%87%E6%9C%BA_MCU_ESP8266_CP340" data-v-e6f2a212><div><h1 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-label="Permalink to &quot;简介&quot;">​</a></h1><p><strong>纯新手程序员</strong>, 想体验一下物联网,打算做一个联网控制的开关.</p><p>搜了一下最便宜的就是ESP8226,教程也多.</p><p>有服务器,打算自己搭建MQTT(by RabiitMQ)来控制, 不好搞就http/tcp来控制</p><p>用游戏引擎Godot开发跨平台程序, 不好搞就android原生开发或者网页开发</p><p>下面是单片机相关的开发的学习过程</p><h2 id="价格" tabindex="-1">价格 <a class="header-anchor" href="#价格" aria-label="Permalink to &quot;价格&quot;">​</a></h2><p>ESP8266开发板的使用过程, 长这个样子,是ESP-12E加上<strong>CH340</strong>之后加电压转换等模块后的一个开发板, 在淘宝的大树聚买的,9.9板子的费用+3块钱的运费</p><p><img src="http://www.taichi-maker.com/wp-content/uploads/2017/12/NodeMCU2.jpg" alt="图片如下"></p><h2 id="参考教程" tabindex="-1">参考教程 <a class="header-anchor" href="#参考教程" aria-label="Permalink to &quot;参考教程&quot;">​</a></h2><p>参考的是<a href="http://www.taichi-maker.com/" target="_blank" rel="noreferrer">太极创客</a>的教程, 用的是<strong>Arduino</strong>(C++)开发的.</p><p>bilibili<a href="https://www.bilibili.com/video/BV1L7411c7jw?p=5" target="_blank" rel="noreferrer">视频链接</a></p><p>ps: 他开发板卖的是真的贵</p><h2 id="主流开发方式如" tabindex="-1">主流开发方式如: <a class="header-anchor" href="#主流开发方式如" aria-label="Permalink to &quot;主流开发方式如:&quot;">​</a></h2><p>我们要知道想在单片机上跑程序,要把代码编译为2进制程序(.bin/.hex)给单片机用,你可以用汇编编译.</p><p>也可以用其他的高级语言编译, 下面是一些编译方式, 具体用每一个编译器开发过程不再这里讲述,大概说一下他们之间的区别</p><ul><li><p>RTOS</p><p>RTOS是一个单片机系统,实现了多用户管理, 官方给了一套SDK(C/C++语言),可以调用SDK里面的接口实现控制单片机的目的,SDK中还用cmake给官方的编译器说了怎么编译,使用该套SDK编译出来的程序可以在RTOS中跑.</p><p>注意RTOS的SDK不支持AT</p></li><li><p>NonOS</p><p>NonOS是none os 没有系统的意思, 官方给了另外一套SDK(C/C++语言),可以调用SDK里面的接口实现控制单片机的目的,无需安装任何单片机系统.SDK中使用makefile指导编译器怎么编译.使用使用该套SDK编译出来的程序可以在RTOS中跑.</p><p>我买的默认刷的固件就是这个.可以直接使用AT.什么是AT:可以理解为用串口通信控制wifi的一些指令.用于其他芯片使用8226作为wifi模块,对wifi的控制</p></li><li><p>MircroPython</p><p>python针对单片机的编译器,支持了8226,据说支持了该芯片大部分操作</p></li><li><p>Arduino</p><p>是一个C/C++编译器,有一个老师嫌弃学生学一个单片机开发太麻烦了, 要先写代码, 然后读手册,烧录.</p><p>学几天都学不会.然后出了一套电路板,给学生学习,同时出了ArduinoIDE用于敲代码和烧录.</p><p>然后大家发现都很好用, 由于是开源的, 有人做了<a href="https://wokwi.com/" target="_blank" rel="noreferrer">wokwi-Arduino在线模拟</a></p><p>有人做了对各种开发板的支持.发展到现在云平台也做.</p><p>对8226做了支持,应该也支持了该芯片的所有功能</p></li><li><p>NodeMcu</p><p>是一个Lua编译器,8226是一家叫乐鑫的公司生产的,他们单独开发了一个Lua编译器</p></li><li><p>AliOS</p><p>同RTOS, 阿里出的</p></li><li><p>tinygo</p><p>同MircroPython, 是一个golang的编译器,仅支持芯片的部分功能,如wifi都不支持!</p></li></ul><h2 id="开发板每一个针脚的作用" tabindex="-1">开发板每一个针脚的作用 <a class="header-anchor" href="#开发板每一个针脚的作用" aria-label="Permalink to &quot;开发板每一个针脚的作用&quot;">​</a></h2><p>视频第2章讲了开发板的,及其对ESP-12E的封装看一下, 了解一下每一个针脚的意思和作用:</p><p><img src="http://www.taichi-maker.com/wp-content/uploads/2016/12/esp8266_devkit_horizontal-01.png" alt=""></p><ul><li><p>灰色中的数字代表对应ESP芯片上的端口的Number.</p><ul><li><p>敲代码的时候可以用过该ID来区分是引脚, 在Arduino也可以通过板子上的名称来控制.</p></li><li><p>如digitalWrite(D2, HIGH)和或digitalWrite(19, HIGH)效果是一样的, 实现就是定义一个变量const D2=19</p></li><li><p>有一个注意点,不能对板子的口子上接5V的电压,要3.3V的,否则板子会烧掉</p></li></ul></li><li><p>深蓝色是对应ESP芯片上端口的名称</p><ul><li>GPIO(general-purpose input/output),通用输入输出接口,可以读取/写入高电平和低电平(就是01)</li><li>Pwm 数值范围是0-1023</li></ul></li><li><p>浅蓝色指的是实现某可以具体功能的接口</p><ul><li>U0/1TXD | U0/1RXD. <ul><li>TXD(Transmit Data 发送数据) RXD: (Receive Data 接收数据), 有2对4个用于向开发板中刷数据,尽量不要用</li></ul></li><li>SPIxxx 用于SPI串口通信</li></ul></li><li><p>绿色的ADC是一个模拟引脚,</p><ul><li>其他的都是数字引脚,模拟引脚就是可以读取具体电压的数值,数字引脚就是只能读出来01.</li><li>读出电压值有什么用?比如一个温度器传感器,其实就是一个热敏电阻,温度改变,阻值也改变,通过电压变化就可以知道对应的温度.</li><li>注意只能输入0-1V的电压,高了会烧掉</li></ul></li><li><p>红色vin图上写了是电源, 可以不通过USB供电</p><ul><li>和PGIO一样不要输入3.3V以上的电压</li></ul></li></ul><h1 id="使用arduino开发esp8226" tabindex="-1">使用Arduino开发ESP8226 <a class="header-anchor" href="#使用arduino开发esp8226" aria-label="Permalink to &quot;使用Arduino开发ESP8226&quot;">​</a></h1><p>因为烧录程序需要一个USB转TTL的工具,有几个芯片可以实现这个功能, 根据芯片型号进行区分: CH340, CP210X</p><p>开发板把这个工具集成到开发板中了,但是从外表也看不出来他是什么芯片,就下了CP210X, 下完后看了一下居然是CH340的.他们是兼容的?暂时不做研究.</p><h2 id="下载并安装驱动" tabindex="-1">下载并安装驱动 <a class="header-anchor" href="#下载并安装驱动" aria-label="Permalink to &quot;下载并安装驱动&quot;">​</a></h2><h3 id="ch210x" tabindex="-1">CH210X <a class="header-anchor" href="#ch210x" aria-label="Permalink to &quot;CH210X&quot;">​</a></h3><p><a href="https://cn.silabs.com/developers/usb-to-uart-bridge-vcp-drivers" target="_blank" rel="noreferrer">官方驱动网址</a></p><p>各种版本的都有windows下的版本很多, macos, linux 都很好理解</p><p>解释几个windows驱动的区别:</p><ul><li>CP210x Universal Windows Driver <ul><li>windows UWD, 就是win8及以上的系统用这个</li><li>根据自己的系统选择64/32位,是一个.sys文件,放在C:\Windows\System32\drivers下即可</li><li>正常来说要regsvr32注册一下的,和注册dll一样</li><li>用按WIN+R组合键，在运行框中输入：regsvr32 .sys文件所在全路径，注意有空格</li></ul></li><li>CP210x Windows Drivers <ul><li>这个就是win7及以下的,根据自己的系统选择64/32位exe, 双击安装即可</li></ul></li></ul><h3 id="ch340" tabindex="-1">CH340 <a class="header-anchor" href="#ch340" aria-label="Permalink to &quot;CH340&quot;">​</a></h3><p><a href="https://www.wch.cn/search?t=all&amp;q=ch340" target="_blank" rel="noreferrer">官方驱动网址</a></p><p>在 驱动&amp;工具 中找 CH340/CH341的USB转串口, 有MacOS, Linux, windows, android.</p><h2 id="测试驱动有没有安装成功" tabindex="-1">测试驱动有没有安装成功 <a class="header-anchor" href="#测试驱动有没有安装成功" aria-label="Permalink to &quot;测试驱动有没有安装成功&quot;">​</a></h2><h3 id="注意数据线" tabindex="-1">注意数据线 <a class="header-anchor" href="#注意数据线" aria-label="Permalink to &quot;注意数据线&quot;">​</a></h3><p>插上开发板, 注意不要用仅2电源线的USB线.带数据传输的USB线插上开发板LED会闪一下,电源线不会</p><h4 id="windows" tabindex="-1">windows <a class="header-anchor" href="#windows" aria-label="Permalink to &quot;windows&quot;">​</a></h4><p>windows下载设备管理器的</p><p>端口(COM和LPT)中可以看到多了一个设备, COM3就是串口号</p><h4 id="macos" tabindex="-1">MacOS <a class="header-anchor" href="#macos" aria-label="Permalink to &quot;MacOS&quot;">​</a></h4><p>控制台输入</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ls /dev/tty.wchusbser*</span></span></code></pre></div><p>提示</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>/dev/tty.wchusbserial1420</span></span></code></pre></div><p>这个1420就是串口号</p><h2 id="为esp8266-nodemcu搭建arduino-ide开发环境" tabindex="-1"><a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/nodemcu-arduino-ide/" target="_blank" rel="noreferrer">为ESP8266-NodeMCU搭建Arduino IDE开发环境</a> <a class="header-anchor" href="#为esp8266-nodemcu搭建arduino-ide开发环境" aria-label="Permalink to &quot;[为ESP8266-NodeMCU搭建Arduino IDE开发环境](http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/nodemcu-arduino-ide/)&quot;">​</a></h2><h3 id="下载arduino-ide" tabindex="-1">下载Arduino IDE <a class="header-anchor" href="#下载arduino-ide" aria-label="Permalink to &quot;下载Arduino IDE&quot;">​</a></h3><p><a href="https://www.arduino.cc/en/software" target="_blank" rel="noreferrer">地址在这</a></p><p>没有代码提示,编译超慢</p><h3 id="添加esp8226的源" tabindex="-1">添加ESP8226的源 <a class="header-anchor" href="#添加esp8226的源" aria-label="Permalink to &quot;添加ESP8226的源&quot;">​</a></h3><p>因为默认不支持ESP8226, 在<strong>Arduino IDE 首选项</strong>中的<strong>附加开发板管理网址</strong>输入, 并点击确定:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>http://arduino.esp8266.com/stable/package_esp8266com_index.json</span></span></code></pre></div><h3 id="添加开发板模版" tabindex="-1">添加开发板模版 <a class="header-anchor" href="#添加开发板模版" aria-label="Permalink to &quot;添加开发板模版&quot;">​</a></h3><p>Arduino IDE-&gt;工具-&gt;开发板-&gt;开发板管理器</p><p>搜索esp8266, 安装即可, 这个其实就相当于makefile,里面还有很多示例</p><p>windows下没有碰到问题</p><p>mac下github有可能不通导致安装失败, 翻墙/改DNS即可</p><h3 id="测试程序和自动烧录烧录" tabindex="-1">测试程序和自动烧录烧录 <a class="header-anchor" href="#测试程序和自动烧录烧录" aria-label="Permalink to &quot;测试程序和自动烧录烧录&quot;">​</a></h3><h4 id="选择测试程序" tabindex="-1">选择测试程序 <a class="header-anchor" href="#选择测试程序" aria-label="Permalink to &quot;选择测试程序&quot;">​</a></h4><p>Arduino IDE-&gt;文件-&gt;示例-&gt;01.Basic-&gt;Blink</p><p>看下代码很简单的代码, 开发板等1s一闪</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>void setup() {</span></span>
<span class="line"><span>  // initialize digital pin LED_BUILTIN as an output.</span></span>
<span class="line"><span>  pinMode(LED_BUILTIN, OUTPUT);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// the loop function runs over and over again forever</span></span>
<span class="line"><span>void loop() {</span></span>
<span class="line"><span>  digitalWrite(LED_BUILTIN, HIGH);   // turn the LED on (HIGH is the voltage level)</span></span>
<span class="line"><span>  delay(1000);                       // wait for a second</span></span>
<span class="line"><span>  digitalWrite(LED_BUILTIN, LOW);    // turn the LED off by making the voltage LOW</span></span>
<span class="line"><span>  delay(1000);                       // wait for a second</span></span>
<span class="line"><span>}</span></span></code></pre></div><h4 id="选择开发板和串口号以供自动烧录" tabindex="-1">选择开发板和串口号以供自动烧录 <a class="header-anchor" href="#选择开发板和串口号以供自动烧录" aria-label="Permalink to &quot;选择开发板和串口号以供自动烧录&quot;">​</a></h4><p>Arduino IDE-&gt;工具-&gt;端口 选择刚才看到的串口号</p><p>Arduino IDE-&gt;工具-&gt;开发板-&gt;esp8226-&gt;NodeMCU1.0(ESP-12E)</p><h4 id="编译并上传到开发板" tabindex="-1">编译并上传到开发板 <a class="header-anchor" href="#编译并上传到开发板" aria-label="Permalink to &quot;编译并上传到开发板&quot;">​</a></h4><p>Arduino IDE-&gt;点击编译(验证)/上传</p><p>点击编译(验证) 会编译程序</p><p>点击上传 如果没有编译会先编译再上传</p><h2 id="网络相关" tabindex="-1">网络相关 <a class="header-anchor" href="#网络相关" aria-label="Permalink to &quot;网络相关&quot;">​</a></h2><p>ESP8226可以AP(WirelessAccessPoint)模式,接入点模式, 建立一个网络, 当做服务器来使用. 就是所谓的组网/网关</p><p>也可以STA(Station))终端模式, 加入其他的网络</p><p>也可以同时存在</p><p><a href="https://github.com/esp8266/Arduino" target="_blank" rel="noreferrer">代码在这</a></p><p><a href="https://arduino-esp8266.readthedocs.io/en/latest/" target="_blank" rel="noreferrer">文档在这</a></p><h3 id="ap模式" tabindex="-1">AP模式 <a class="header-anchor" href="#ap模式" aria-label="Permalink to &quot;AP模式&quot;">​</a></h3><h4 id="最简单的示例" tabindex="-1">最简单的示例 <a class="header-anchor" href="#最简单的示例" aria-label="Permalink to &quot;最简单的示例&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#include &lt;ESP8266WiFi.h&gt;  </span></span>
<span class="line"><span>const char *ssid = &quot;ESP8226&quot;; // 这里定义将要建立的WiFi名称。此处以&quot;taichi-maker&quot;为示例</span></span>
<span class="line"><span>                                   // 您可以将自己想要建立的WiFi名称填写入此处的双引号中</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>const char *password = &quot;12345678&quot;;  // 这里定义将要建立的WiFi密码。此处以12345678为示例</span></span>
<span class="line"><span>                                    // 您可以将自己想要使用的WiFi密码放入引号内</span></span>
<span class="line"><span>                                    // 如果建立的WiFi不要密码，则在双引号内不要填入任何信息</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>void setup() {</span></span>
<span class="line"><span>  Serial.begin(9600);              // 启动串口通讯</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>  WiFi.softAP(ssid, password);     // 此语句是重点。WiFi.softAP用于启动NodeMCU的AP模式。</span></span>
<span class="line"><span>                                   // 括号中有两个参数，ssid是WiFi名。password是WiFi密码。</span></span>
<span class="line"><span>                                   // 这两个参数具体内容在setup函数之前的位置进行定义。</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>  Serial.print(&quot;Access Point: &quot;);    // 通过串口监视器输出信息</span></span>
<span class="line"><span>  Serial.println(ssid);              // 告知用户NodeMCU所建立的WiFi名</span></span>
<span class="line"><span>  Serial.print(&quot;IP address: &quot;);      // 以及NodeMCU的IP地址</span></span>
<span class="line"><span>  Serial.println(WiFi.softAPIP());   // 通过调用WiFi.softAPIP()可以得到NodeMCU的IP地址</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>void loop() { </span></span>
<span class="line"><span>}</span></span></code></pre></div><h4 id="如何获取到print数据" tabindex="-1">如何获取到print数据 <a class="header-anchor" href="#如何获取到print数据" aria-label="Permalink to &quot;如何获取到print数据&quot;">​</a></h4><p>打开Arduino IDE-&gt;串口监视器</p><p>因为此时程序已经启动过了,打印过了. 所以没有任何东西,要手动在开发板上按一下reset, 重新启动.就会出现了</p><h3 id="无线终端模式-station" tabindex="-1">无线终端模式(Station) <a class="header-anchor" href="#无线终端模式-station" aria-label="Permalink to &quot;无线终端模式(Station)&quot;">​</a></h3><h4 id="连接wifi" tabindex="-1"><strong>连接WiFI</strong> <a class="header-anchor" href="#连接wifi" aria-label="Permalink to &quot;**连接WiFI**&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>/*</span></span>
<span class="line"><span>NodeMCU无线终端模式连接WiFi</span></span>
<span class="line"><span>By 太极创客（http://www.taichi-maker.com）</span></span>
<span class="line"><span>2019-03-11</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>本示例程序用于演示如何使用NodeMCU无线终端模式连接WiFi</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>如需获得更多关于如何使用NodeMCU开发物联网的教程和资料信息</span></span>
<span class="line"><span>请参考太极创客网站（http://www.taichi-maker.com）</span></span>
<span class="line"><span>并在首页搜索栏中搜索关键字：物联网</span></span>
<span class="line"><span>*/</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>#include &lt;ESP8266WiFi.h&gt;        // 本程序使用ESP8266WiFi库</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>const char* ssid     = &quot;taichi-maker&quot;;      // 连接WiFi名（此处使用taichi-maker为示例）</span></span>
<span class="line"><span>                                            // 请将您需要连接的WiFi名填入引号中</span></span>
<span class="line"><span>const char* password = &quot;12345678&quot;;          // 连接WiFi密码（此处使用12345678为示例）</span></span>
<span class="line"><span>                                            // 请将您需要连接的WiFi密码填入引号中</span></span>
<span class="line"><span>                                            </span></span>
<span class="line"><span>void setup() {</span></span>
<span class="line"><span>  Serial.begin(9600);         // 启动串口通讯</span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>  WiFi.begin(ssid, password);                  // 启动网络连接</span></span>
<span class="line"><span>  Serial.print(&quot;Connecting to &quot;);              // 串口监视器输出网络连接信息</span></span>
<span class="line"><span>  Serial.print(ssid); Serial.println(&quot; ...&quot;);  // 告知用户NodeMCU正在尝试WiFi连接</span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>  int i = 0;                                   // 这一段程序语句用于检查WiFi是否连接成功</span></span>
<span class="line"><span>  while (WiFi.status() != WL_CONNECTED) {      // WiFi.status()函数的返回值是由NodeMCU的WiFi连接状态所决定的。 </span></span>
<span class="line"><span>    delay(1000);                               // 如果WiFi连接成功则返回值为WL_CONNECTED                       </span></span>
<span class="line"><span>    Serial.print(i++); Serial.print(&#39; &#39;);      // 此处通过While循环让NodeMCU每隔一秒钟检查一次WiFi.status()函数返回值</span></span>
<span class="line"><span>  }                                            // 同时NodeMCU将通过串口监视器输出连接时长读秒。</span></span>
<span class="line"><span>                                               // 这个读秒是通过变量i每隔一秒自加1来实现的。</span></span>
<span class="line"><span>                                               </span></span>
<span class="line"><span>  Serial.println(&quot;&quot;);                          // WiFi连接成功后</span></span>
<span class="line"><span>  Serial.println(&quot;Connection established!&quot;);   // NodeMCU将通过串口监视器输出&quot;连接成功&quot;信息。</span></span>
<span class="line"><span>  Serial.print(&quot;IP address:    &quot;);             // 同时还将输出NodeMCU的IP地址。这一功能是通过调用</span></span>
<span class="line"><span>  Serial.println(WiFi.localIP());              // WiFi.localIP()函数来实现的。该函数的返回值即NodeMCU的IP地址。</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>void loop() {                                   </span></span>
<span class="line"><span>}</span></span></code></pre></div><h4 id="自动连接最强信号wifi网络" tabindex="-1"><strong>自动连接最强信号WiFi网络</strong> <a class="header-anchor" href="#自动连接最强信号wifi网络" aria-label="Permalink to &quot;**自动连接最强信号WiFi网络**&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>/*</span></span>
<span class="line"><span>NodeMCU无线终端模式连接WiFi-2</span></span>
<span class="line"><span>By 太极创客（http://www.taichi-maker.com）</span></span>
<span class="line"><span>2019-03-11</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>此程序将会控制NodeMCU在当前的网络环境里搜索预先存储好的WiFi。</span></span>
<span class="line"><span>一旦找到预存的WiFi名称，NodeMCU将会使用预存的密码信息尝试连接该WiFi。</span></span>
<span class="line"><span>如果同时找到多个预存WiFi，NodeMCU将会尝试连接信号最强的WiFi。</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>如需获得更多关于如何使用NodeMCU开发物联网的教程和资料信息</span></span>
<span class="line"><span>请参考太极创客网站（http://www.taichi-maker.com）</span></span>
<span class="line"><span>并在首页搜索栏中搜索关键字：物联网</span></span>
<span class="line"><span>*/</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>#include &lt;ESP8266WiFi.h&gt;          // 本程序使用ESP8266WiFi库</span></span>
<span class="line"><span>#include &lt;ESP8266WiFiMulti.h&gt;   // 本程序使用ESP8266WiFiMulti库</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>ESP8266WiFiMulti wifiMulti;     // 建立ESP8266WiFiMulti对象,对象名称是&#39;wifiMulti&#39;</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>void setup() {</span></span>
<span class="line"><span>  Serial.begin(9600);            // 启动串口通讯</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>//通过addAp函数存储  WiFi名称       WiFi密码</span></span>
<span class="line"><span>  wifiMulti.addAP(&quot;taichi-maker&quot;, &quot;12345678&quot;);  // 这三条语句通过调用函数addAP来记录3个不同的WiFi网络信息。</span></span>
<span class="line"><span>  wifiMulti.addAP(&quot;taichi-maker2&quot;, &quot;87654321&quot;); // 这3个WiFi网络名称分别是taichi-maker, taichi-maker2, taichi-maker3。</span></span>
<span class="line"><span>  wifiMulti.addAP(&quot;taichi-maker3&quot;, &quot;13572468&quot;); // 这3个网络的密码分别是123456789，87654321，13572468。</span></span>
<span class="line"><span>                                                // 此处WiFi信息只是示例，请在使用时将需要连接的WiFi信息填入相应位置。</span></span>
<span class="line"><span>                                                // 另外这里只存储了3个WiFi信息，您可以存储更多的WiFi信息在此处。</span></span>
<span class="line"><span>                                                </span></span>
<span class="line"><span>  Serial.println(&quot;Connecting ...&quot;);         // 通过串口监视器输出信息告知用户NodeMCU正在尝试连接WiFi</span></span>
<span class="line"><span>  int i = 0;                                 </span></span>
<span class="line"><span>  while (wifiMulti.run() != WL_CONNECTED) {  // 此处的wifiMulti.run()是重点。通过wifiMulti.run()，NodeMCU将会在当前</span></span>
<span class="line"><span>    delay(1000);                             // 环境中搜索addAP函数所存储的WiFi。如果搜到多个存储的WiFi那么NodeMCU</span></span>
<span class="line"><span>    Serial.print(&#39;.&#39;);                       // 将会连接信号最强的那一个WiFi信号。</span></span>
<span class="line"><span>  }                                           // 一旦连接WiFI成功，wifiMulti.run()将会返回“WL_CONNECTED”。这也是</span></span>
<span class="line"><span>                                              // 此处while循环判断是否跳出循环的条件。</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>  Serial.println(&#39;\n&#39;);                     // WiFi连接成功后</span></span>
<span class="line"><span>  Serial.print(&quot;Connected to &quot;);            // NodeMCU将通过串口监视器输出。</span></span>
<span class="line"><span>  Serial.println(WiFi.SSID());              // 连接的WiFI名称</span></span>
<span class="line"><span>  Serial.print(&quot;IP address:\t&quot;);            // 以及</span></span>
<span class="line"><span>  Serial.println(WiFi.localIP());           // NodeMCU的IP地址</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>void loop() { </span></span>
<span class="line"><span>}</span></span></code></pre></div><h2 id="web-server" tabindex="-1">Web server <a class="header-anchor" href="#web-server" aria-label="Permalink to &quot;Web server&quot;">​</a></h2><h3 id="simple" tabindex="-1">simple <a class="header-anchor" href="#simple" aria-label="Permalink to &quot;simple&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>/**********************************************************************</span></span>
<span class="line"><span>项目名称/Project          : 零基础入门学用物联网</span></span>
<span class="line"><span>程序名称/Program name     : 3_2_1_First_Web_Server</span></span>
<span class="line"><span>团队/Team                : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)</span></span>
<span class="line"><span>作者/Author              : CYNO朔</span></span>
<span class="line"><span>日期/Date（YYYYMMDD）     : 20191107</span></span>
<span class="line"><span>程序目的/Purpose          : 使用NodeMCU建立基本服务器。用户可通过浏览器使用8266的IP地址</span></span>
<span class="line"><span>                           访问8266所建立的基本网页（Hello from ESP8266）</span></span>
<span class="line"><span>-----------------------------------------------------------------------</span></span>
<span class="line"><span>修订历史/Revision History  </span></span>
<span class="line"><span>日期/Date    作者/Author      参考号/Ref    修订说明/Revision Description</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>***********************************************************************/</span></span>
<span class="line"><span>#include &lt;ESP8266WiFi.h&gt;        // 本程序使用 ESP8266WiFi库</span></span>
<span class="line"><span>#include &lt;ESP8266WiFiMulti.h&gt;   //  ESP8266WiFiMulti库</span></span>
<span class="line"><span>#include &lt;ESP8266WebServer.h&gt;   //  ESP8266WebServer库</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>ESP8266WiFiMulti wifiMulti;     // 建立ESP8266WiFiMulti对象,对象名称是&#39;wifiMulti&#39;</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>ESP8266WebServer esp8266_server(80);// 建立ESP8266WebServer对象，对象名称为esp8266_server</span></span>
<span class="line"><span>                                    // 括号中的数字是网路服务器响应http请求的端口号</span></span>
<span class="line"><span>                                    // 网络服务器标准http端口号为80，因此这里使用80为端口号</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>void setup(void){</span></span>
<span class="line"><span>  Serial.begin(9600);          // 启动串口通讯</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>  //通过addAp函数存储  WiFi名称       WiFi密码</span></span>
<span class="line"><span>  wifiMulti.addAP(&quot;Xiaomi_66E1&quot;, &quot;53130000&quot;);  // 这三条语句通过调用函数addAP来记录3个不同的WiFi网络信息。</span></span>
<span class="line"><span>  int i = 0;                                 </span></span>
<span class="line"><span>  while (wifiMulti.run() != WL_CONNECTED) {  // 此处的wifiMulti.run()是重点。通过wifiMulti.run()，NodeMCU将会在当前</span></span>
<span class="line"><span>    delay(1000);                             // 环境中搜索addAP函数所存储的WiFi。如果搜到多个存储的WiFi那么NodeMCU</span></span>
<span class="line"><span>    Serial.print(i++); Serial.print(&#39; &#39;);    // 将会连接信号最强的那一个WiFi信号。</span></span>
<span class="line"><span>  }                                          // 一旦连接WiFI成功，wifiMulti.run()将会返回“WL_CONNECTED”。这也是</span></span>
<span class="line"><span>                                             // 此处while循环判断是否跳出循环的条件。</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>  // WiFi连接成功后将通过串口监视器输出连接成功信息 </span></span>
<span class="line"><span>  Serial.println(&#39;\n&#39;);                     // WiFi连接成功后</span></span>
<span class="line"><span>  Serial.print(&quot;Connected to &quot;);            // NodeMCU将通过串口监视器输出。</span></span>
<span class="line"><span>  Serial.println(WiFi.SSID());              // 连接的WiFI名称</span></span>
<span class="line"><span>  Serial.print(&quot;IP address:\t&quot;);            // 以及</span></span>
<span class="line"><span>  Serial.println(WiFi.localIP());           // NodeMCU的IP地址</span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>//--------&quot;启动网络服务功能&quot;程序部分开始-------- //  此部分为程序为本示例程序重点1</span></span>
<span class="line"><span>  esp8266_server.begin();                   //  详细讲解请参见太极创客网站《零基础入门学用物联网》</span></span>
<span class="line"><span>  esp8266_server.on(&quot;/&quot;, handleRoot);       //  第3章-第2节 ESP8266-NodeMCU网络服务器-1</span></span>
<span class="line"><span>  esp8266_server.onNotFound(handleNotFound);        </span></span>
<span class="line"><span>//--------&quot;启动网络服务功能&quot;程序部分结束--------</span></span>
<span class="line"><span>  Serial.println(&quot;HTTP esp8266_server started&quot;);//  告知用户ESP8266网络服务功能已经启动</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>/* 以下函数语句为本示例程序重点3</span></span>
<span class="line"><span>详细讲解请参见太极创客网站《零基础入门学用物联网》</span></span>
<span class="line"><span>第3章-第2节 3_2_1_First_Web_Server 的说明讲解*/  </span></span>
<span class="line"><span>void loop(void){</span></span>
<span class="line"><span>  esp8266_server.handleClient();     // 处理http服务器访问</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>/* 以下两个函数为本示例程序重点2</span></span>
<span class="line"><span>详细讲解请参见太极创客网站《零基础入门学用物联网》</span></span>
<span class="line"><span>第3章-第2节 3_2_1_First_Web_Server 的说明讲解*/                                                                            </span></span>
<span class="line"><span>void handleRoot() {   //处理网站根目录“/”的访问请求 </span></span>
<span class="line"><span>  esp8266_server.send(200, &quot;text/plain&quot;, &quot;Hello from ESP8266&quot;);   // NodeMCU将调用此函数。</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>// 设置处理404情况的函数&#39;handleNotFound&#39;</span></span>
<span class="line"><span>void handleNotFound(){                                        // 当浏览器请求的网络资源无法在服务器找到时，</span></span>
<span class="line"><span>  esp8266_server.send(404, &quot;text/plain&quot;, &quot;404: Not found&quot;);   // NodeMCU将调用此函数。</span></span>
<span class="line"><span>}</span></span></code></pre></div><h3 id="通过网络服务将开发板引脚状态显示在网页中" tabindex="-1">通过网络服务将开发板引脚状态显示在网页中 <a class="header-anchor" href="#通过网络服务将开发板引脚状态显示在网页中" aria-label="Permalink to &quot;通过网络服务将开发板引脚状态显示在网页中&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>/**********************************************************************</span></span>
<span class="line"><span>项目名称/Project          : 零基础入门学用物联网</span></span>
<span class="line"><span>程序名称/Program name     : 3_2_4_Pin_State_Display_Auto_Refresh</span></span>
<span class="line"><span>团队/Team                : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)</span></span>
<span class="line"><span>作者/Author              : CYNO朔</span></span>
<span class="line"><span>日期/Date（YYYYMMDD）     : 20200128</span></span>
<span class="line"><span>程序目的/Purpose          : 使用NodeMCU建立基本服务器。该网页将显示引脚D3状态。同时状态会</span></span>
<span class="line"><span>                           每隔5秒钟更新一次。</span></span>
<span class="line"><span>-----------------------------------------------------------------------</span></span>
<span class="line"><span>修订历史/Revision History  </span></span>
<span class="line"><span>日期/Date    作者/Author      参考号/Ref    修订说明/Revision Description</span></span>
<span class="line"><span></span></span>
<span class="line"><span>***********************************************************************/</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#include &lt;ESP8266WiFi.h&gt;        // 本程序使用 ESP8266WiFi库</span></span>
<span class="line"><span>#include &lt;ESP8266WiFiMulti.h&gt;   //  ESP8266WiFiMulti库</span></span>
<span class="line"><span>#include &lt;ESP8266WebServer.h&gt;   //  ESP8266WebServer库</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#define buttonPin D3            // 按钮引脚D3</span></span>
<span class="line"><span></span></span>
<span class="line"><span>ESP8266WiFiMulti wifiMulti;     // 建立ESP8266WiFiMulti对象,对象名称是&#39;wifiMulti&#39;</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>ESP8266WebServer esp8266_server(80);// 建立网络服务器对象，该对象用于响应HTTP请求。监听端口（80）</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>bool pinState;                      // 存储引脚状态用变量</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void setup(){</span></span>
<span class="line"><span>  Serial.begin(9600);          // 启动串口通讯</span></span>
<span class="line"><span>  delay(10);</span></span>
<span class="line"><span>  Serial.println(&quot;&quot;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  pinMode(buttonPin, INPUT_PULLUP); // 将按键引脚设置为输入上拉模式</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  wifiMulti.addAP(&quot;ssid_from_AP_1&quot;, &quot;your_password_for_AP_1&quot;); // 将需要连接的一系列WiFi ID和密码输入这里</span></span>
<span class="line"><span>  wifiMulti.addAP(&quot;ssid_from_AP_2&quot;, &quot;your_password_for_AP_2&quot;); // ESP8266-NodeMCU在启动后会扫描当前网络</span></span>
<span class="line"><span>  wifiMulti.addAP(&quot;ssid_from_AP_3&quot;, &quot;your_password_for_AP_3&quot;); // 环境查找是否有这里列出的WiFi ID。如果有</span></span>
<span class="line"><span>  Serial.println(&quot;Connecting ...&quot;);                            // 则尝试使用此处存储的密码进行连接。</span></span>
<span class="line"><span>                                                               // 另外这里只存储了3个WiFi信息，您可以存储更多</span></span>
<span class="line"><span>                                                               // 的WiFi信息在此处。</span></span>
<span class="line"><span>  int i = 0;                                 </span></span>
<span class="line"><span>  while (wifiMulti.run() != WL_CONNECTED) {  // 此处的wifiMulti.run()是重点。通过wifiMulti.run()，NodeMCU将会在当前</span></span>
<span class="line"><span>    delay(1000);                             // 环境中搜索addAP函数所存储的WiFi。如果搜到多个存储的WiFi那么NodeMCU</span></span>
<span class="line"><span>    Serial.print(i++); Serial.print(&#39; &#39;);    // 将会连接信号最强的那一个WiFi信号。</span></span>
<span class="line"><span>  }                                          // 一旦连接WiFI成功，wifiMulti.run()将会返回“WL_CONNECTED”。这也是</span></span>
<span class="line"><span>                                             // 此处while循环判断是否跳出循环的条件。</span></span>
<span class="line"><span>  // WiFi连接成功后将通过串口监视器输出连接成功信息 </span></span>
<span class="line"><span>  Serial.println(&#39;\n&#39;);                     // WiFi连接成功后</span></span>
<span class="line"><span>  Serial.print(&quot;Connected to &quot;);            // NodeMCU将通过串口监视器输出。</span></span>
<span class="line"><span>  Serial.println(WiFi.SSID());              // 连接的WiFI名称</span></span>
<span class="line"><span>  Serial.print(&quot;IP address:\t&quot;);            // 以及</span></span>
<span class="line"><span>  Serial.println(WiFi.localIP());           // NodeMCU的IP地址</span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>  esp8266_server.begin();                  </span></span>
<span class="line"><span>  esp8266_server.on(&quot;/&quot;, handleRoot);      </span></span>
<span class="line"><span>  esp8266_server.onNotFound(handleNotFound);        </span></span>
<span class="line"><span></span></span>
<span class="line"><span>  Serial.println(&quot;HTTP esp8266_server started&quot;);//  告知用户ESP8266网络服务功能已经启动</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void loop(){</span></span>
<span class="line"><span>  esp8266_server.handleClient();     // 处理http服务器访问</span></span>
<span class="line"><span>  pinState = digitalRead(buttonPin); // 获取引脚状态</span></span>
<span class="line"><span>}                                                                   </span></span>
<span class="line"><span></span></span>
<span class="line"><span>/* 以下函数处理网站首页的访问请求。此函数为本示例程序重点1</span></span>
<span class="line"><span>详细讲解请参见太极创客网站《零基础入门学用物联网》</span></span>
<span class="line"><span>第3章-第2节“通过网络服务将开发板引脚状态显示在网页中”的说明讲解。*/    </span></span>
<span class="line"><span>void handleRoot() {   //处理网站目录“/”的访问请求 </span></span>
<span class="line"><span>  esp8266_server.send(200, &quot;text/html&quot;, sendHTML(pinState));  </span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/*</span></span>
<span class="line"><span>建立用于发送给客户端浏览器的HTML代码。此代码将会每隔5秒刷新页面。</span></span>
<span class="line"><span>通过页面刷新，引脚的最新状态也会显示于页面中</span></span>
<span class="line"><span>*/</span></span>
<span class="line"><span>String sendHTML(bool buttonState){</span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>  String htmlCode = &quot;&lt;!DOCTYPE html&gt; &lt;html&gt;\n&quot;;</span></span>
<span class="line"><span>  htmlCode +=&quot;&lt;head&gt;&lt;meta http-equiv=&#39;refresh&#39; content=&#39;5&#39;/&gt;\n&quot;;</span></span>
<span class="line"><span>  htmlCode +=&quot;&lt;title&gt;ESP8266 Butoon State&lt;/title&gt;\n&quot;;</span></span>
<span class="line"><span>  htmlCode +=&quot;&lt;style&gt;html { font-family: Helvetica; display: inline-block; margin: 0px auto; text-align: center;}\n&quot;;</span></span>
<span class="line"><span>  htmlCode +=&quot;body{margin-top: 50px;} h1 {color: #444444;margin: 50px auto 30px;} h3 {color: #444444;margin-bottom: 50px;}\n&quot;;</span></span>
<span class="line"><span>  htmlCode +=&quot;&lt;/style&gt;\n&quot;;</span></span>
<span class="line"><span>  htmlCode +=&quot;&lt;/head&gt;\n&quot;;</span></span>
<span class="line"><span>  htmlCode +=&quot;&lt;body&gt;\n&quot;;</span></span>
<span class="line"><span>  htmlCode +=&quot;&lt;h1&gt;ESP8266 BUTTON STATE&lt;/h1&gt;\n&quot;;</span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>  if(buttonState)</span></span>
<span class="line"><span>    {htmlCode +=&quot;&lt;p&gt;Button Status: HIGH&lt;/p&gt;\n&quot;;}</span></span>
<span class="line"><span>  else</span></span>
<span class="line"><span>    {htmlCode +=&quot;&lt;p&gt;Button Status: LOW&lt;/p&gt;\n&quot;;}</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>  htmlCode +=&quot;&lt;/body&gt;\n&quot;;</span></span>
<span class="line"><span>  htmlCode +=&quot;&lt;/html&gt;\n&quot;;</span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>  return htmlCode;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 设置处理404情况的函数&#39;handleNotFound&#39;</span></span>
<span class="line"><span>void handleNotFound(){                                        // 当浏览器请求的网络资源无法在服务器找到时，</span></span>
<span class="line"><span>  esp8266_server.send(404, &quot;text/plain&quot;, &quot;404: Not found&quot;);   // NodeMCU将调用此函数。</span></span>
<span class="line"><span>}</span></span></code></pre></div><h3 id="按钮切换led状态" tabindex="-1">按钮切换led状态 <a class="header-anchor" href="#按钮切换led状态" aria-label="Permalink to &quot;按钮切换led状态&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#include &lt;ESP8266WiFi.h&gt;        // 本程序使用 ESP8266WiFi库</span></span>
<span class="line"><span>#include &lt;ESP8266WiFiMulti.h&gt;   //  ESP8266WiFiMulti库</span></span>
<span class="line"><span>#include &lt;ESP8266WebServer.h&gt;   //  ESP8266WebServer库</span></span>
<span class="line"><span>ESP8266WiFiMulti wifiMulti;     // 建立ESP8266WiFiMulti对象,对象名称是 &#39;wifiMulti&#39;</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>ESP8266WebServer esp8266_server(80);// 建立网络服务器对象，该对象用于响应HTTP请求。监听端口（80）</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>void setup(void){</span></span>
<span class="line"><span>  Serial.begin(9600);   // 启动串口通讯</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>  pinMode(LED_BUILTIN, OUTPUT); //设置内置LED引脚为输出模式以便控制LED</span></span>
<span class="line"><span>  digitalWrite(LED_BUILTIN, HIGH);</span></span>
<span class="line"><span>  wifiMulti.addAP(&quot;Xiaomi_66E1&quot;, &quot;53130000&quot;); // 将需要连接的一系列WiFi ID和密码输入这里</span></span>
<span class="line"><span>  Serial.println(&quot;Connecting ...&quot;);                            // 则尝试使用此处存储的密码进行连接。</span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>  int i = 0;                                 </span></span>
<span class="line"><span>  while (wifiMulti.run() != WL_CONNECTED) {  // 此处的wifiMulti.run()是重点。通过wifiMulti.run()，NodeMCU将会在当前</span></span>
<span class="line"><span>    delay(1000);                             // 环境中搜索addAP函数所存储的WiFi。如果搜到多个存储的WiFi那么NodeMCU</span></span>
<span class="line"><span>    Serial.print(i++); Serial.print(&#39; &#39;);    // 将会连接信号最强的那一个WiFi信号。</span></span>
<span class="line"><span>  }                                          // 一旦连接WiFI成功，wifiMulti.run()将会返回“WL_CONNECTED”。这也是</span></span>
<span class="line"><span>                                             // 此处while循环判断是否跳出循环的条件。</span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>  // WiFi连接成功后将通过串口监视器输出连接成功信息 </span></span>
<span class="line"><span>  Serial.println(&#39;\n&#39;);</span></span>
<span class="line"><span>  Serial.print(&quot;Connected to &quot;);</span></span>
<span class="line"><span>  Serial.println(WiFi.SSID());              // 通过串口监视器输出连接的WiFi名称</span></span>
<span class="line"><span>  Serial.print(&quot;IP address:\t&quot;);</span></span>
<span class="line"><span>  Serial.println(WiFi.localIP());           // 通过串口监视器输出ESP8266-NodeMCU的IP</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>  esp8266_server.begin();                           // 启动网站服务</span></span>
<span class="line"><span>  esp8266_server.on(&quot;/&quot;, HTTP_GET, handleRoot);     // 设置服务器根目录即&#39;/&#39;的函数&#39;handleRoot&#39;</span></span>
<span class="line"><span>  esp8266_server.on(&quot;/LED&quot;, HTTP_POST, handleLED);  // 设置处理LED控制请求的函数&#39;handleLED&#39;</span></span>
<span class="line"><span>  esp8266_server.onNotFound(handleNotFound);        // 设置处理404情况的函数&#39;handleNotFound&#39;</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>  Serial.println(&quot;HTTP esp8266_server started&quot;);//  告知用户ESP8266网络服务功能已经启动</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>void loop(void){</span></span>
<span class="line"><span>  esp8266_server.handleClient();                     // 检查http服务器访问</span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>}</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>/*设置服务器根目录即&#39;/&#39;的函数&#39;handleRoot&#39;</span></span>
<span class="line"><span>  该函数的作用是每当有客户端访问NodeMCU服务器根目录时，</span></span>
<span class="line"><span>  NodeMCU都会向访问设备发送 HTTP 状态 200 (Ok) 这是send函数的第一个参数。</span></span>
<span class="line"><span>  同时NodeMCU还会向浏览器发送HTML代码，以下示例中send函数中第三个参数，</span></span>
<span class="line"><span>  也就是双引号中的内容就是NodeMCU发送的HTML代码。该代码可在网页中产生LED控制按钮。 </span></span>
<span class="line"><span>  当用户按下按钮时，浏览器将会向NodeMCU的/LED页面发送HTTP请求，请求方式为POST。</span></span>
<span class="line"><span>  NodeMCU接收到此请求后将会执行handleLED函数内容*/</span></span>
<span class="line"><span>void handleRoot() {       </span></span>
<span class="line"><span>  bool pinState;  // 存储引脚状态用变量</span></span>
<span class="line"><span>  pinState = !digitalRead(LED_BUILTIN);                 // 获取引脚状态</span></span>
<span class="line"><span>  String displayPinState;                   // 存储按键状态的字符串变量</span></span>
<span class="line"><span>  Serial.println(pinState);  </span></span>
<span class="line"><span>  if(pinState == HIGH){                     // 当按键引脚D3为高电平</span></span>
<span class="line"><span>    displayPinState = &quot;HIGH&quot;; // 字符串赋值高电平信息</span></span>
<span class="line"><span>  } else {                                  // 当按键引脚D3为低电平</span></span>
<span class="line"><span>    displayPinState = &quot;LOW&quot;;  // 字符串赋值低电平信息</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  esp8266_server.send(200, &quot;text/html&quot;, &quot;&lt;form action=\&quot;/LED\&quot; method=\&quot;POST\&quot;&gt;Button State: &lt;input type=\&quot;submit\&quot; value=\&quot;&quot;+displayPinState+&quot;\&quot;&gt;&lt;/form&gt;&quot;);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>//处理LED控制请求的函数&#39;handleLED&#39;</span></span>
<span class="line"><span>void handleLED() {                          </span></span>
<span class="line"><span>  digitalWrite(LED_BUILTIN,!digitalRead(LED_BUILTIN));// 改变LED的点亮或者熄灭状态</span></span>
<span class="line"><span>  esp8266_server.sendHeader(&quot;Location&quot;,&quot;/&quot;);          // 跳转回页面根目录</span></span>
<span class="line"><span>  esp8266_server.send(303);                           // 发送Http相应代码303 跳转  </span></span>
<span class="line"><span>}</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>// 设置处理404情况的函数&#39;handleNotFound&#39;</span></span>
<span class="line"><span>void handleNotFound(){</span></span>
<span class="line"><span>  esp8266_server.send(404, &quot;text/plain&quot;, &quot;404: Not found&quot;); // 发送 HTTP 状态 404 (未找到页面) 并向浏览器发送文字 &quot;404: Not found&quot;</span></span>
<span class="line"><span>}</span></span></code></pre></div><h3 id="通过flash-d3-上拉输入控制led" tabindex="-1">通过flash D3 上拉输入控制led <a class="header-anchor" href="#通过flash-d3-上拉输入控制led" aria-label="Permalink to &quot;通过flash D3 上拉输入控制led&quot;">​</a></h3><h2 id="闪存文件系统" tabindex="-1">闪存文件系统 <a class="header-anchor" href="#闪存文件系统" aria-label="Permalink to &quot;闪存文件系统&quot;">​</a></h2><h3 id="初始化" tabindex="-1">初始化 <a class="header-anchor" href="#初始化" aria-label="Permalink to &quot;初始化&quot;">​</a></h3><p>Arduino IDE-&gt;工具-&gt;Flash seize-&gt;3MB</p><p>在上传程序的时候会初始化文件闪存系统</p><h3 id="插件安装" tabindex="-1">插件安装 <a class="header-anchor" href="#插件安装" aria-label="Permalink to &quot;插件安装&quot;">​</a></h3><p>在当前项目目录下新建tool, 整个插件文件夹放在里面</p><h2 id="碰到的问题" tabindex="-1">碰到的问题 <a class="header-anchor" href="#碰到的问题" aria-label="Permalink to &quot;碰到的问题&quot;">​</a></h2><h3 id="编译器不会检查返回值有没有被初始化" tabindex="-1">编译器不会检查返回值有没有被初始化 <a class="header-anchor" href="#编译器不会检查返回值有没有被初始化" aria-label="Permalink to &quot;编译器不会检查返回值有没有被初始化&quot;">​</a></h3><p>如果定义了返回值,但是没有返回的话</p><p>编译的过去,但是报错,然后单片机重启, 找了很长时间</p><h3 id="上传文件和控制台不能同时开" tabindex="-1">上传文件和控制台不能同时开 <a class="header-anchor" href="#上传文件和控制台不能同时开" aria-label="Permalink to &quot;上传文件和控制台不能同时开&quot;">​</a></h3><p>因为他们都是用的串口通信</p><h3 id="板载led是低电平的时候亮" tabindex="-1">板载LED是低电平的时候亮 <a class="header-anchor" href="#板载led是低电平的时候亮" aria-label="Permalink to &quot;板载LED是低电平的时候亮&quot;">​</a></h3><p>为什么因为电路图这样设计的,这样设计的原因是:</p><p>详情了解灌电流和拉电流的概念</p><h3 id="编译提示重复定义" tabindex="-1">编译提示重复定义 <a class="header-anchor" href="#编译提示重复定义" aria-label="Permalink to &quot;编译提示重复定义&quot;">​</a></h3><p>编译的时候会搜索整个文件夹-&gt;如果有2个重复的文件,在同一个文件中找了半天找不到第二个重复名称的函数,太不智能了啊.</p><h3 id="吐槽arduino" tabindex="-1">吐槽Arduino <a class="header-anchor" href="#吐槽arduino" aria-label="Permalink to &quot;吐槽Arduino&quot;">​</a></h3><ul><li><p>没有代码提示,这是人干的事儿么. 非8226代码支持的贼棒</p></li><li><p>ctrl不能跳转.h文件,要看自己去找源码看, 太麻烦了</p></li><li><p>编译太慢了,一个几十k的程序,你他妈要编10s以上,离谱了</p></li><li><p>没有错误检查机制,要自己编译检查,编译又慢的一批,效率太低了</p></li><li><p>没有行号, 报错多少行,很难找</p></li><li><p>用记事本编辑后不会自动同步到IDE</p></li><li><p>字体不能修改, )} 等等很像,看了半天没看出来</p></li><li><p>乱报错, 明明是一个函数漏写了,报的是{什么的</p></li><li><p>定位错误,编译器报的行数和定位的行数不一样</p></li><li><p>报错信息不太对,明明是漏写了小括号,提示函数没有定义</p></li><li><p>编译过了还能运行报错,没有抓错机制, 一报错就单片机重启</p></li></ul></div></div></main><footer class="VPDocFooter" data-v-e6f2a212 data-v-1bcd8184><!--[--><!--]--><!----><!----></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div><div class="site-footer footer" data-v-54b3b317> Powered by <a class="vitepress" target="_blank" href="//vitepress.vuejs.org/">VitePress - 1.4.1</a></div><!--]--></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"CZJ-J2a3\",\"pages_archives.md\":\"DTt_nvxg\",\"pages_category.md\":\"rUJFk_X-\",\"pages_index.md\":\"hmdEUQDx\",\"pages_tags.md\":\"BixSLeeG\",\"posts_golang_expvar.md\":\"hd9mi7lT\",\"posts_golang_go-http.md\":\"DV-cUBMp\",\"posts_golang_go私有仓库.md\":\"CP_JSp34\",\"posts_golang_grpcgetway.md\":\"CaPKFHrm\",\"posts_golang_jaeger.md\":\"C-PTr86m\",\"posts_golang_kafka.md\":\"dh414do9\",\"posts_golang_protocolbuffers_zip.md\":\"BZXff3UU\",\"posts_golang_simple_http_golang.md\":\"BqaC3wkw\",\"posts_golang_wg导致的提前返回.md\":\"B8_URuHx\",\"posts_golang_用hysteria2做ip池.md\":\"_thFYDgT\",\"posts_linux_netdata.md\":\"CzSHPbwj\",\"posts_linux_nginx_limit.md\":\"DQSrvhqr\",\"posts_linux_nginx_ssi.md\":\"UvxUi260\",\"posts_linux_nsq.md\":\"Bl5s4BPb\",\"posts_linux_redis_run_docker.md\":\"CCdghceX\",\"posts_linux_sshadd.md\":\"BgSzL6xi\",\"posts_linux_云原生的前世今生_k8s.md\":\"CTxdMx5b\",\"posts_linux_云原生的前世今生_云原生.md\":\"2-7tYyrQ\",\"posts_linux_云原生的前世今生_云原生的前世今生.md\":\"BFVv4J8u\",\"posts_linux_云原生的前世今生_云造价实现方案.md\":\"BKNkxkf5\",\"posts_linux_跨平台编译基础.md\":\"D9efLlO9\",\"posts_python_python_math.md\":\"DZBp6DDV\",\"posts_windows_innosetup.md\":\"B7zE4486\",\"posts_单片机_mcu_esp8266-nodemcu.md\":\"LyWwBHYB\",\"posts_单片机_mcu_esp8266_cp340.md\":\"Cgbo4t1u\",\"posts_单片机_mcu_wifi_killer.md\":\"Cs3YpGlF\",\"posts_单片机_mcu_wokwi-uno.md\":\"XsRv6zTJ\",\"posts_单片机_tcp46.md\":\"MCMPcaHC\",\"posts_单片机_xiaomi_openwrt.md\":\"npriwplA\",\"posts_单片机_xiaomi_rathole.md\":\"zw7BvcxA\",\"posts_密码_专利.md\":\"D4UyIl7G\",\"posts_杂记_github-desktop使用clash代理验证失败的问题.md\":\"rSM_L-JC\",\"posts_杂记_pad.md\":\"D2GC002x\",\"posts_杂记_testflow.md\":\"Cwv4ylx5\",\"posts_杂记_tor介绍.md\":\"DExjD5k3\",\"posts_运维_ci脚本_ci脚本说明.md\":\"Bb3kqDXj\",\"posts_运维_gossip.md\":\"BbGkKwLG\",\"posts_运维_mqtt.md\":\"DtjETKrV\",\"posts_运维_prometheus_grafana.md\":\"CMajUw_C\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"Para's\",\"description\":\"A VitePress Site\",\"base\":\"/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"pageSize\":10,\"posts\":[{\"frontMatter\":{\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":273,\"tags\":[\"运维\"],\"category\":\"运维\",\"title\":\"prometheus&grafana\"},\"regularPath\":\"/posts/运维/prometheus&grafana.html\"},{\"frontMatter\":{\"title\":\"\\\"MQTT入门\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":7722,\"tags\":[\"运维\"],\"category\":\"运维\",\"description\":\"\"},\"regularPath\":\"/posts/运维/mqtt.html\"},{\"frontMatter\":{\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":6011,\"tags\":[\"运维\"],\"category\":\"运维\",\"title\":\"gossip\",\"description\":\"Gossip协议是一个通信协议，一种传播消息的方式，灵感来自于：瘟疫、社交网络等。使用Gossip协议的有：Redis Cluster、Consul、Apache Cassandra等。\"},\"regularPath\":\"/posts/运维/gossip.html\"},{\"frontMatter\":{\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":1407,\"tags\":[\"运维\",\"CI脚本\"],\"category\":\"CI脚本\",\"title\":\"CI脚本说明\",\"description\":\"持续集成Continuous Integration(CI)()和持续交付Continuous Delivery(CD)\\n\\nCI :代码->svn exe (自动构建exe到测试环境)\\n\\nCD: svn exe->用户  (测试环境到自动发版)\\n\\nCI/CD流程体验:[github action](https://github.com/marketplace?type=actions)\\n\\ngithub action实现原理是[云原生](.\\\\云原生的前世今生\\\\云原生的前世今生.md)\"},\"regularPath\":\"/posts/运维/CI脚本/CI脚本说明.html\"},{\"frontMatter\":{\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":494,\"tags\":[\"杂记\"],\"category\":\"杂记\",\"title\":\"tor介绍\",\"description\":\"\"},\"regularPath\":\"/posts/杂记/tor介绍.html\"},{\"frontMatter\":{\"title\":\"\\\"记一次阿里code-flow(云效)git pull出现的问题\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":1807,\"tags\":[\"杂记\"],\"category\":\"杂记\",\"description\":\"git pull 本地可以 但是通过阿里flow 不可以\"},\"regularPath\":\"/posts/杂记/testflow.html\"},{\"frontMatter\":{\"title\":\"\\\"笔记本推荐\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":5077,\"tags\":[\"杂记\"],\"category\":\"杂记\",\"description\":\"\"},\"regularPath\":\"/posts/杂记/pad.html\"},{\"frontMatter\":{\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":1603,\"tags\":[\"杂记\"],\"category\":\"杂记\",\"title\":\"github-desktop使用clash代理验证失败的问题\",\"description\":\"使用git命令上传会出现:`Warning: the ECDSA host key for 'github.com' differs from the key for the IP address '198.18.0.8'`\\n\\n出现这个警告是因为 SSH 客户端发现 `github.com` 的 ECDSA 主机密钥与 `198.18.0.8` 的密钥不同。可能的原因包括：\\n\\n1. **DNS 劫持或攻击**：如果你连接的是假的 GitHub 服务器，SSH 会警告密钥不匹配。\\n2. **代理或 VPN 设置**：某些网络代理或 VPN 可能会导致连接 IP 地址的变更，进而导致密钥不一致。\\n3. **GitHub IP 地址变化**：在 GitHub 的 IP 地址改变后，本地 SSH 客户端可能会认为新的 IP 地址不是以前的主机密钥，显示此警告。\"},\"regularPath\":\"/posts/杂记/github-desktop使用clash代理验证失败的问题.html\"},{\"frontMatter\":{\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":7613,\"tags\":[\"密码\"],\"category\":\"密码\",\"title\":\"专利\",\"description\":\"**技术领域**\\n\\n人工智能和工程造价的(自动匹配单价引用)组合应用\\n\\n**背景技术**\\n\\n+ 数据的清洗整理和Onehot处理\\n+ LogisticRegression(逻辑回归)\\n\\n**发明内容**\\n\\n用户户在导入工程之后,需手动对清单定额进行单价引用以达到多条清单同步价格的目的,该技术可以部分代替用户输入,自动对多条清单的同步单价关系自动关联\\n\\n**附图**\\n\\n\\n\\n**具体实施方式**\"},\"regularPath\":\"/posts/密码/专利.html\"},{\"frontMatter\":{\"title\":\"\\\"小米4a 内网穿透\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":1232,\"tags\":[\"单片机\"],\"category\":\"单片机\",\"description\":\"\"},\"regularPath\":\"/posts/单片机/xiaomi_rathole.html\"},{\"frontMatter\":{\"title\":\"\\\"小米4a刷openert\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":2988,\"tags\":[\"单片机\"],\"category\":\"单片机\",\"description\":\"网上教程乱七八糟的, 这里整理一下, 最新的[这个](https://www.luyouwang.net/9751.html)能用\\n\\n[官网在这里](https://openwrt.org/inbox/toh/xiaomi/r4ac?s[]=xiaomi&s[]=4a)\\n\\n注意4a百兆 和千兆的刷的包是不一样的\"},\"regularPath\":\"/posts/单片机/xiaomi_openwrt.html\"},{\"frontMatter\":{\"title\":\"\\\"golang tcp6 网无法访问\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":2373,\"tags\":[\"单片机\"],\"category\":\"单片机\",\"description\":\"\"},\"regularPath\":\"/posts/单片机/tcp46.html\"},{\"frontMatter\":{\"title\":\"\\\"上拉电阻和下拉电阻的模拟\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":1745,\"tags\":[\"单片机\",\"MCU\"],\"category\":\"MCU\",\"description\":\"因为引用了github里面的asm, 所以github必须通, 可以翻墙/其他方法 解决\\n\\n看控制台就知道了\"},\"regularPath\":\"/posts/单片机/MCU/wokwi-UNO.html\"},{\"frontMatter\":{\"title\":\"\\\"wifi kill 是如何工作的\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":1966,\"tags\":[\"单片机\",\"MCU\"],\"category\":\"MCU\",\"description\":\"[官方源码在这里](https://github.com/spacehuhntech/esp8266_deauther/)\\n\\n云盘: https://wwu.lanzouy.com/i83vl0aiducj\\n\\n提供了bin 和 Arduino 两种安装方式\\n\\n总而言之就是利用wifi协议的漏洞, wifi提供方是大爷,所以协议没有对wifi提供方做太多限制\"},\"regularPath\":\"/posts/单片机/MCU/Wifi_killer.html\"},{\"frontMatter\":{\"title\":\"\\\"ESP8266开发板的使用\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":30987,\"tags\":[\"单片机\",\"MCU\"],\"category\":\"MCU\",\"description\":\"**纯新手程序员**, 想体验一下物联网,打算做一个联网控制的开关.\\n\\n搜了一下最便宜的就是ESP8226,教程也多.\\n\\n有服务器,打算自己搭建MQTT(by RabiitMQ)来控制, 不好搞就http/tcp来控制\\n\\n用游戏引擎Godot开发跨平台程序, 不好搞就android原生开发或者网页开发\\n\\n下面是单片机相关的开发的学习过程\"},\"regularPath\":\"/posts/单片机/MCU/ESP8266_CP340.html\"},{\"frontMatter\":{\"title\":\"\\\"ESP8266-NodeMCU\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":24377,\"tags\":[\"单片机\",\"MCU\"],\"category\":\"MCU\",\"description\":\"我是小白,对智能家居很感兴趣,之前wifi/物联网太贵了,学习成本太高了.发现ESP8266太便宜了,还带wifi.想用ESP8266做一个简单的智能插座.基本就是整个学习过程\"},\"regularPath\":\"/posts/单片机/MCU/ESP8266-NodeMCU.html\"},{\"frontMatter\":{\"title\":\"\\\"python sympy 解方程\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":856,\"tags\":[\"python\"],\"category\":\"python\"},\"regularPath\":\"/posts/python/python_math.html\"},{\"frontMatter\":{\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":7620,\"tags\":[\"golang\"],\"category\":\"golang\",\"title\":\"用hysteria2做ip池\",\"description\":\"+ 起因爬虫做了ip的并发限制，大量爬取之后ip被封，所以想用hysteria2做ip池.\\n+ 为什么用hysteria2也是因为目前来看hysteria2用的比ss多\\n+ hysteria2/clash/ss 这些本身编译好的程序都是不支持 访问同一个网站的时候使用不同ip的.唯一方案是开启多个客户端,但是很麻烦.\\n+ ip池本身使用的是clash的配置文件\\n+ 这种pr官方肯定不会接受... 放一下魔改了的源码\"},\"regularPath\":\"/posts/golang/用hysteria2做ip池.html\"},{\"frontMatter\":{\"title\":\"\\\"wg导致的提前返回\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":1794,\"tags\":[\"golang\"],\"category\":\"golang\",\"description\":\"#### 逻辑描述: \\n\\n给定一个int数组, 返回一个map, 该map包含该数组及对该数组数字的处理\"},\"regularPath\":\"/posts/golang/wg导致的提前返回.html\"},{\"frontMatter\":{\"title\":\"\\\"golang http demo\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":844,\"tags\":[\"golang\"],\"category\":\"golang\"},\"regularPath\":\"/posts/golang/simple_http_golang.html\"},{\"frontMatter\":{\"title\":\"\\\"Kafka入门\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":6555,\"tags\":[\"golang\"],\"category\":\"golang\",\"description\":\"\"},\"regularPath\":\"/posts/golang/kafka.html\"},{\"frontMatter\":{\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":1100,\"tags\":[\"golang\"],\"category\":\"golang\",\"title\":\"jaeger\"},\"regularPath\":\"/posts/golang/jaeger.html\"},{\"frontMatter\":{\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":512,\"tags\":[\"golang\"],\"category\":\"golang\",\"title\":\"grpcgetway\"},\"regularPath\":\"/posts/golang/grpcgetway.html\"},{\"frontMatter\":{\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":203,\"tags\":[\"golang\"],\"category\":\"golang\",\"title\":\"go私有仓库\"},\"regularPath\":\"/posts/golang/go私有仓库.html\"},{\"frontMatter\":{\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":1618,\"tags\":[\"golang\"],\"category\":\"golang\",\"title\":\"go-http\"},\"regularPath\":\"/posts/golang/go-http.html\"},{\"frontMatter\":{\"title\":\"\\\"expvar 简单使用\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":1283,\"tags\":[\"golang\"],\"category\":\"golang\",\"description\":\"> Package expvar provides a standardized interface to public variables, such as operation counters in servers. It exposes these variables via HTTP at **/debug/vars** in JSON format.\\n\\n> In addition to adding the HTTP handler, this package registers the following variables:\\n\\n```\\ncmdline   os.Args\\nmemstats  runtime.Memstats\\n```\\n\\n> The package is sometimes only imported for the side effect of registering its HTTP handler and the above variables. To use it this way, link this package into your program:\\n\\n导入包就是使用了, 会自动添加一个**/debug/vars**的http 服务, 具体实现看源码, 很简单, \\n\\n有一个多线程 map读写锁的实现\\n\\n```\\nimport _ \\\"expvar\\\"\\n```\"},\"regularPath\":\"/posts/golang/expvar.html\"},{\"frontMatter\":{\"title\":\"\\\"Protocol Buffers压缩(编码)原理\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":16689,\"tags\":[\"golang\"],\"category\":\"golang\",\"description\":\"\"},\"regularPath\":\"/posts/golang/ProtocolBuffers_zip.html\"},{\"frontMatter\":{\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":2314,\"tags\":[\"Windows\"],\"category\":\"Windows\",\"title\":\"innosetup\",\"description\":\"\"},\"regularPath\":\"/posts/Windows/innosetup.html\"},{\"frontMatter\":{\"title\":\"\\\"跨平台编译基础\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":20933,\"tags\":[\"Linux\"],\"category\":\"Linux\",\"description\":\"\"},\"regularPath\":\"/posts/Linux/跨平台编译基础.html\"},{\"frontMatter\":{\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":455,\"tags\":[\"Linux\",\"云原生的前世今生\"],\"category\":\"云原生的前世今生\",\"title\":\"云造价实现方案\",\"description\":\"由于用户数量的不确定性 一台服务器不一定够用, 采用云原生的方式构建, 方便上云和重新构建\"},\"regularPath\":\"/posts/Linux/云原生的前世今生/云造价实现方案.html\"},{\"frontMatter\":{\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":4147,\"tags\":[\"Linux\",\"云原生的前世今生\"],\"category\":\"云原生的前世今生\",\"title\":\"云原生的前世今生\",\"description\":\"![](img\\\\微服务.webp)\\n\\n![](img\\\\微服务2.webp)\"},\"regularPath\":\"/posts/Linux/云原生的前世今生/云原生的前世今生.html\"},{\"frontMatter\":{\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":6255,\"tags\":[\"Linux\",\"云原生的前世今生\"],\"category\":\"云原生的前世今生\",\"title\":\"云原生\",\"description\":\"xshell \\n\\n~~ftp~~~\\n\\nsftp\"},\"regularPath\":\"/posts/Linux/云原生的前世今生/云原生.html\"},{\"frontMatter\":{\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":2407,\"tags\":[\"Linux\",\"云原生的前世今生\"],\"category\":\"云原生的前世今生\",\"title\":\"k8s\",\"description\":\"\"},\"regularPath\":\"/posts/Linux/云原生的前世今生/k8s.html\"},{\"frontMatter\":{\"title\":\"\\\"git 免密登录\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":853,\"tags\":[\"Linux\"],\"category\":\"Linux\",\"description\":\"git 分为2种模式:\\n\\nssh 形如: git@codeup.aliyun.com:para/hugo.git\\n\\nhttps 形如: https://codeup.aliyun.com/para/hugo.git\"},\"regularPath\":\"/posts/Linux/sshadd.html\"},{\"frontMatter\":{\"title\":\"\\\"redis 在docker中慢的原因分析\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":5916,\"tags\":[\"Linux\"],\"category\":\"Linux\",\"description\":\"本来想实际测试一下mysql和redis到底差了多少, 按10w次, 发现mysql 用了18s,  redis 用了15s,这不合理啊, 分析下原因, 确定是docker下跑redis的原因\\n\\n[和这个问题是一样的](https://stackoverflow.com/questions/21691540/how-to-optimize-performance-for-a-docker-container)\"},\"regularPath\":\"/posts/Linux/redis_run_docker.html\"},{\"frontMatter\":{\"title\":\"\\\"nginx ssi入门\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":622,\"tags\":[\"Linux\"],\"category\":\"Linux\",\"description\":\"修改nginx.conf\\n\\n```\\n        location /ssi {\\n\\t\\t\\tssi on;\\n\\t\\t\\tssi_silent_errors on;\\n\\t\\t\\tssi_types text/shtml;\\n\\t\\t\\troot   html;\\n        }\\t\\n```\\n\\n添加 `html/ssi/ssi.html`\\n```\\n<!--#include file=\\\"header.html\\\"-->\\n<div> this is content by ssi </div>\\n<!--#include file=\\\"footer.html\\\"-->\\n```\\n添加 `html/ssi/header.html`\\n```\\n<div>this is header</div>\\n```\\n添加 `html/ssi/footer.html`\\n```\\n<div>this is footer</div>\\n```\"},\"regularPath\":\"/posts/Linux/nginx_ssi.html\"},{\"frontMatter\":{\"title\":\"\\\"Nginx 限流\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":11665,\"tags\":[\"Linux\"],\"category\":\"Linux\",\"description\":\"\"},\"regularPath\":\"/posts/Linux/nginx_limit.html\"},{\"frontMatter\":{\"title\":\"\\\"netdata\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":491,\"tags\":[\"Linux\"],\"category\":\"Linux\"},\"regularPath\":\"/posts/Linux/netdata.html\"},{\"frontMatter\":{\"title\":\"\\\"NSQ入门\\\"\",\"hidemeta\":\"true\",\"date\":\"2024-12-09\",\"modify\":\"2024-12-09\",\"size\":3326,\"tags\":[\"Linux\"],\"category\":\"Linux\",\"description\":\"1. 解耦，将一个流程加入一层数据接口拆分成两个部分，上游专注通知，下游专注处理\\n2. 缓冲，应对流量的突然上涨变更，消息队列有很好的缓冲削峰作用\\n3. 异步，上游发送消息以后可以马上返回，处理工作交给下游进行\\n4. 广播，让一个消息被多个下游进行处理\\n5. 冗余，保存处理的消息，防止消息处理失败导致的数据丢失\"},\"regularPath\":\"/posts/Linux/NSQ.html\"}],\"logo\":\"/logo.svg\",\"nav\":[{\"text\":\"Home\",\"link\":\"/\"},{\"text\":\"Pages\",\"link\":\"/pages/\"},{\"text\":\"Category\",\"link\":\"/pages/category\"},{\"text\":\"Archives\",\"link\":\"/pages/archives\"},{\"text\":\"Tags\",\"link\":\"/pages/tags\"}],\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/vuejs/vitepress\"}],\"search\":{\"provider\":\"local\"}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>