import{_ as e,c as t,a2 as i,o as l}from"./chunks/framework.DDqBDuc9.js";const u=JSON.parse('{"title":"跨平台编译基础","description":"","frontmatter":{"title":"跨平台编译基础","hidemeta":true},"headers":[],"relativePath":"posts/Linux/跨平台编译基础.md","filePath":"posts/Linux/跨平台编译基础.md"}'),s={name:"posts/Linux/跨平台编译基础.md"};function n(o,a,r,p,d,c){return l(),t("div",null,a[0]||(a[0]=[i(`<h1 id="集成电路发展史" tabindex="-1"><a href="https://baijiahao.baidu.com/s?id=1704133753207266151&amp;wfr=spider&amp;for=pc" target="_blank" rel="noreferrer">集成电路发展史</a> <a class="header-anchor" href="#集成电路发展史" aria-label="Permalink to &quot;[集成电路发展史](https://baijiahao.baidu.com/s?id=1704133753207266151&amp;wfr=spider&amp;for=pc)&quot;">​</a></h1><h2 id="指令集的发展" tabindex="-1">指令集的发展 <a class="header-anchor" href="#指令集的发展" aria-label="Permalink to &quot;指令集的发展&quot;">​</a></h2><ol><li><p>芯片的本质是二极管, 为了在芯片上跑程序, 出现了指令集(ISA)这个东西.</p></li><li><p>指令集分两大流派: 复杂指令集（CISC）精简指令集（RISC)</p></li></ol><table tabindex="0"><thead><tr><th>指令集ISA</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>复杂指令集CISC(Complex Instruction Set Computing)</td><td>一条指令中完成更多的工作, 最大限度榨干硬件</td><td>日趋庞杂的指令芯片不但不易实现，而且还可能降低系统性能</td></tr><tr><td>精简指令集RISC(Reduced Instruction Set Computer)</td><td>芯片容易实现</td><td>多条指令才能完成一个任务, 造成硬件的浪费</td></tr></tbody></table><h3 id="比较主流的指令集" tabindex="-1">比较主流的指令集 <a class="header-anchor" href="#比较主流的指令集" aria-label="Permalink to &quot;比较主流的指令集&quot;">​</a></h3><ol><li>CISC 发展出了 <ul><li>X86</li><li>8051</li></ul></li><li>RISC百花齐放, <ul><li>ARM(Acorn RISC Machine)</li><li>MIPS(Microprocessor without interlocked pipelined stages 无内部互锁流水级的微处理器)</li><li><a href="https://zh.wikipedia.org/wiki/RISC-V" target="_blank" rel="noreferrer">RISC-V</a>(开源BSD)</li><li>AVR</li><li>PIC</li><li>PowerPC</li></ul></li><li>还有一些专门针对某些运算出来的指令集, 这些并不能用上面两个标准区分如: <ul><li>DSP</li><li>FPGA</li><li>EPSXX</li></ul></li></ol><h3 id="为什么有这么多isa" tabindex="-1"><a href="https://zhuanlan.zhihu.com/p/64199775" target="_blank" rel="noreferrer">为什么有这么多ISA</a>? <a class="header-anchor" href="#为什么有这么多isa" aria-label="Permalink to &quot;[为什么有这么多ISA](https://zhuanlan.zhihu.com/p/64199775)?&quot;">​</a></h3><ul><li><p>X86和ARM指令集的实现方式都是闭源的</p></li><li><p>x86架构由于授权问题只有几家可以生产，包括现在的Intel、AMD</p></li><li><p><a href="https://zh.wikipedia.org/wiki/ARM%E6%9E%B6%E6%A7%8B#ARM%E6%8E%88%E6%AC%8A%E6%96%B9%E5%BC%8F" target="_blank" rel="noreferrer">但是ARM有多种授权方式</a></p><ul><li>ARM公司本身并不靠自有的设计来制造或出售CPU，而是将处理器架构授权给有兴趣的厂家。</li><li>如苹果M1,M2.海思部分麒麟处理器就是采用这种方式生产出来的。</li><li>x86是占了先手的, ARM<a href="https://zh.wikipedia.org/wiki/ARM%E6%9E%B6%E6%A7%8B" target="_blank" rel="noreferrer">1983</a>年才开始设计,但是授权方式的原因ARM也抢了很多市场.</li><li>从2020年英伟达强势宣布将以400亿美元的价格收购英国ARM公司的事件,可以看出, ARM这种不生成CPU的方式并没有X86这种和intel牢牢绑定的方式赚钱.</li><li>一旦英伟达收购ARM,很难说新的授权方式,因此包括苹果,华为等都开始威胁要拥抱RISC-V</li></ul></li><li><p><a href="https://zh.wikipedia.org/wiki/RISC-V" target="_blank" rel="noreferrer">RISC-V</a> 是开源的(<a href="https://zh.wikipedia.org/wiki/BSD%E8%AE%B8%E5%8F%AF%E8%AF%81" target="_blank" rel="noreferrer">BSD</a>)</p></li></ul><p>如今,复杂指令集和精简指令集界限日渐模糊, 都在吸取别人的优点.在性能和易实现之间做权衡</p><h3 id="x86和arm的优劣势" tabindex="-1">X86和ARM的优劣势 <a class="header-anchor" href="#x86和arm的优劣势" aria-label="Permalink to &quot;X86和ARM的优劣势&quot;">​</a></h3><p>X86结构的电脑采用“桥”的方式与扩展设备（如：硬盘、内存等）进行连接，而且x86结构的电脑出现了近30年，其配套扩展的设备种类多、价格也比较便宜，所以x86结构的电脑能很容易进行性能扩展，如增加内存、硬盘等。</p><p>ARM结构的电脑是通过专用的数据接口使CPU与数据存储设备进行连接，所以ARM的存储、内存等性能扩展难以进行（一般在产品设计时已经定好其内存及数据存储的容量），所以采用ARM结构的系统，一般不考虑扩展。基本奉行“够用就好”的原则。这就是为什么现在苹果电脑不留出多个硬盘/内存接口的原因之一.</p><h3 id="指令集之间是可以转换的" tabindex="-1">指令集之间是可以转换的 <a class="header-anchor" href="#指令集之间是可以转换的" aria-label="Permalink to &quot;指令集之间是可以转换的&quot;">​</a></h3><p>同时还可以软件兼容, M1跑intel芯片的程序, M1不能识别x86的指令苹果就开发了一个叫做<a href="https://zh.wikipedia.org/wiki/Rosetta" target="_blank" rel="noreferrer">Rosetta 2</a> 的转译机制,把x86的复杂指令翻译成ARM的精简指令, 显然这中间必定有效率的问题.</p><h2 id="指令集-isa-与架构与芯片之间的关系" tabindex="-1">指令集(ISA)与架构与芯片之间的关系 <a class="header-anchor" href="#指令集-isa-与架构与芯片之间的关系" aria-label="Permalink to &quot;指令集(ISA)与架构与芯片之间的关系&quot;">​</a></h2><h3 id="什么是架构" tabindex="-1">什么是架构 <a class="header-anchor" href="#什么是架构" aria-label="Permalink to &quot;什么是架构&quot;">​</a></h3><p><a href="https://www.zhihu.com/question/22464046/answer/21450143" target="_blank" rel="noreferrer">架构 architecture：是一个抽象的概念</a></p><p>比如我们常说的计算机处理器有486、Ivy Bridge、Pentium M……这就是架构的不同(但其都从属于<a href="https://link.zhihu.com/?target=http%3A//zh.wikipedia.org/wiki/X86" target="_blank" rel="noreferrer">x86</a>架构)</p><p>ARMv1~ARMv8到STM32这些名称都属于ARM架构</p><h2 id="麒麟支持哪些cpu" tabindex="-1">麒麟支持哪些CPU? <a class="header-anchor" href="#麒麟支持哪些cpu" aria-label="Permalink to &quot;麒麟支持哪些CPU?&quot;">​</a></h2><p><em>麒麟</em>操作<em>系统</em>能全面<em>支持飞腾、龙芯、兆芯、申威、海光、鲲鹏</em>六款主流国产<em>CPU</em></p><table tabindex="0"><thead><tr><th>CPU</th><th>架构</th><th></th></tr></thead><tbody><tr><td>飞腾</td><td>ARM</td><td></td></tr><tr><td>龙芯</td><td>LoongArch/MIPS64</td><td></td></tr><tr><td>兆芯</td><td>X86</td><td></td></tr><tr><td><s>申威</s>~</td><td><s>Alpha</s></td><td>用于超级计算机</td></tr><tr><td>海光</td><td>X86</td><td></td></tr><tr><td>鲲鹏</td><td>ARM</td><td></td></tr></tbody></table><h3 id="六个经典单片机种类介绍" tabindex="-1"><a href="https://baijiahao.baidu.com/s?id=1690664375387238551&amp;wfr=spider&amp;for=pc" target="_blank" rel="noreferrer">六个经典单片机种类介绍</a> <a class="header-anchor" href="#六个经典单片机种类介绍" aria-label="Permalink to &quot;[六个经典单片机种类介绍](https://baijiahao.baidu.com/s?id=1690664375387238551&amp;wfr=spider&amp;for=pc)&quot;">​</a></h3><h4 id="_51单片机" tabindex="-1">51单片机 <a class="header-anchor" href="#_51单片机" aria-label="Permalink to &quot;51单片机&quot;">​</a></h4><p>51单片机是对所有兼容Intel8051指令系统的单片机的统称, 如</p><ul><li>Intel（<a href="https://baike.baidu.com/item/%E8%8B%B1%E7%89%B9%E5%B0%94/305730" target="_blank" rel="noreferrer">英特尔</a>）：80C31、<a href="https://baike.baidu.com/item/80C51/4200558" target="_blank" rel="noreferrer">80C51</a>、87C51，80C32、80C52、87C52等；</li><li><a href="https://baike.baidu.com/item/Atmel/8207336" target="_blank" rel="noreferrer">Atmel</a>（艾特梅尔）：89C51、89C52、89C2051，89S51(RC)，89S52(RC)等；</li><li>Philips（<a href="https://baike.baidu.com/item/%E9%A3%9E%E5%88%A9%E6%B5%A6/14316" target="_blank" rel="noreferrer">飞利浦</a>）、华邦、Dallas（达拉斯）、Siemens（<a href="https://baike.baidu.com/item/%E8%A5%BF%E9%97%A8%E5%AD%90/25878" target="_blank" rel="noreferrer">西门子</a>）等公司的许多产品；</li><li>STC（宏晶）：STC89C51、STC90C51、STC11系列、STC15系列、STC8, STC16系列等。</li><li>等</li></ul><p>他们并不都是8位的: 如STC16是个32位的8051, 阉割为了16位</p><p>51单片机泛滥的原因:</p><ul><li>intel看不上看不上这块肉了, 同时要和其他人竞争, 就开放了授权</li><li>入场早,前面学习的人都是用的这个</li></ul><h4 id="avr-pic-powerpc-mips" tabindex="-1">AVR/PIC/PowerPC/MIPS <a class="header-anchor" href="#avr-pic-powerpc-mips" aria-label="Permalink to &quot;AVR/PIC/PowerPC/MIPS&quot;">​</a></h4><ul><li><p>PIC芯片示例:</p><ul><li>PIC16C5X，PIC12C6XX, PIC17CXX</li></ul></li><li><p>AVR芯片示例: 比较典型的就是Altera、Lattice、Xilinx世界三大权威公司</p><ul><li>AlteraEPM7128S(PLCC84)、LatticeLC4128V(TQFP100)、XilinxXC95108(PLCC84)</li></ul></li><li><p>MIPS是卖得最好的RISCCPU</p><ul><li>MIPS324Kc, MIPS645Kc</li><li>如Sony，Nintendo的游戏机，Cisco的路由器和SGI超级计算机</li></ul></li><li><p>PowerPC</p><ul><li>任天堂Gamecube</li></ul></li></ul><p>都是跟8051单片机的机构不同的位单片机，因为结构不同，所以他的汇编指令也不同，并且他们都是使用的RISC指令集，只有几十条指令，大部分的还都是单周期的指令，所以在相同的晶振频率下，比8051速度要快.但是他们不属于ARM架构, 算是和ARM同时期发展出来的RISC指令集.</p><h4 id="arm" tabindex="-1">ARM <a class="header-anchor" href="#arm" aria-label="Permalink to &quot;ARM&quot;">​</a></h4><ul><li><p>手机芯片,任天堂游戏机, iPod:</p><p>GameBoyAdvance，NintendoDS，iPodARM9TDMIArmadillo，GP32，GP2X（第一颗内核）,TapwaveZodiac（Motorolai.MX1）；GP2X（第二颗内核）ARM9ENintendoDS，NokiaN-GageConexant802.11chips；STM32, STMicroSTR91xF，ARM11NokiaN93，Zune，NokiaN800，NOKIAE72CortexTexasInstrumentsOMAP3；Broadcomisauser；LuminaryMicro</p></li></ul><p>他的内部资源（寄存器和外设功能）较8051、AVR和PIC都要多的多，基本上接近于计算机的CPU了</p><h4 id="dsp-fpga" tabindex="-1">DSP/FPGA <a class="header-anchor" href="#dsp-fpga" aria-label="Permalink to &quot;DSP/FPGA&quot;">​</a></h4><p>DSP其实也是一种特殊的单片机，他从8bit到32bit的都有，他专门是用来计算数字信号的，在某些计算公式上，他甚至比现在的家用计算机的最快CPU还要快，比如说一个32bit的DSP能在一个指令周期内完成一个32bit数乘以32bit数再加上一个32bit数的计算。不好定义属于CISC还是RISC</p><h1 id="单片机的各种编程语言" tabindex="-1">单片机的各种编程语言 <a class="header-anchor" href="#单片机的各种编程语言" aria-label="Permalink to &quot;单片机的各种编程语言&quot;">​</a></h1><h2 id="汇编语言" tabindex="-1">汇编语言 <a class="header-anchor" href="#汇编语言" aria-label="Permalink to &quot;汇编语言&quot;">​</a></h2><p>汇编不是编程语言，他只是机器指令和一些宏的组合。</p><p>为了用人类看得懂的语言来描述指令集, 就有了汇编语言, 不同架构的汇编语言是不一样的,ARM的汇编语言与Intel X86的就不同。</p><h2 id="汇编语言编译器" tabindex="-1">汇编语言编译器 <a class="header-anchor" href="#汇编语言编译器" aria-label="Permalink to &quot;汇编语言编译器&quot;">​</a></h2><ul><li>AVR Studio</li></ul><h2 id="高级语言" tabindex="-1">高级语言 <a class="header-anchor" href="#高级语言" aria-label="Permalink to &quot;高级语言&quot;">​</a></h2><p>虽然汇编语言读起来方便了，但也有缺陷。首先汇编语言操作起来还是挺麻烦的。其次汇编语言对应一条条指令集，所以当指令集改变时，就得修改相应汇编语言，导致其可移植性很差，不能跨平台使用，这时人们就想开发一种更方便操作，超越指令集的语言，于是有了C，C++等<strong>高级语言</strong>.</p><h3 id="c-c-语言" tabindex="-1">C/C++语言 <a class="header-anchor" href="#c-c-语言" aria-label="Permalink to &quot;C/C++语言&quot;">​</a></h3><ul><li><p>大部分单片机支持C语言编译出来的二进制文件, 但是像FPGA就不支持C语言<a href="https://www.elecfans.com/tags/verilog/" target="_blank" rel="noreferrer">verilog</a>和VHDL语言或者C语言无法编译出FPGA需要的二进制文件,因为C语言是先出现的.</p></li><li><p>至于C++, 要看编译器支不支持, 把C++编译为对应指令集2进制的东西, 理论上来说C++是可以用C的代码复写的,但是这个事情太庞大了, C++是一直更新的现在都C++20了.如Keil支持STL库</p><ul><li><p>但是C++对运行效率有很大的影响, CPU速率大于100MHz不用考虑C++语言本身对程序运行效率的影响</p></li><li><p>C++编译出来的东西比C大很多, 各种库使用都会增大体积, Flash一般要大于100K</p></li><li><p>C++的编译器要针对 在针对8位MCU, 32位MCU做不一样的处理(地址长度都不一样)</p></li><li><p>C++的各种库不一定对单片机支持: 如STL标准库</p></li><li><p>C++11、C++14和C++17还是有不小区别的。不能有换编译器的需求</p></li><li><p>C++ 并没有比C写起来快很多</p><p>But mind you, writing complex code in C can give you nightmares.</p><p>But then debugging C++ code can give you nightmares as well.</p></li><li><p>C++写的时候有时候要 提前分配存储空间，而不是自动分配.否则会有小概率情况会出问题</p></li></ul></li></ul><h4 id="c-c编译器" tabindex="-1">C++/C编译器: <a class="header-anchor" href="#c-c编译器" aria-label="Permalink to &quot;C++/C编译器:&quot;">​</a></h4><h5 id="keil" tabindex="-1">Keil <a class="header-anchor" href="#keil" aria-label="Permalink to &quot;Keil&quot;">​</a></h5><p>Keil公司2005年由ARM公司收购。现在已经迭代到 Keil μVision5,</p><p>支持ARM, 51单片机</p><h5 id="iar-stvd-iccavr" tabindex="-1">IAR/STVD/ICCAVR <a class="header-anchor" href="#iar-stvd-iccavr" aria-label="Permalink to &quot;IAR/STVD/ICCAVR&quot;">​</a></h5><p>ST系列芯片用STVD</p><p>IAR,ICCAVR用于AVR</p><h5 id="arduinoide" tabindex="-1"><a href="https://www.arduino.cc/" target="_blank" rel="noreferrer">ArduinoIDE</a> <a class="header-anchor" href="#arduinoide" aria-label="Permalink to &quot;[ArduinoIDE](https://www.arduino.cc/)&quot;">​</a></h5><p>Arduino2005 才开始出现, 有人嫌弃学一个单片机开发太麻烦了, 要先写代码, 然后读手册,烧录.</p><p>学几天都学不会.然后出了一套电路板,给学生学习,同时出了ArduinoIDE用于敲代码和烧录.</p><p>然后大家发现都很好用, 由于是开源的, 有人做了<a href="https://wokwi.com/" target="_blank" rel="noreferrer">wokwi-Arduino在线模拟</a></p><p>有人做了对各种开发板的支持.发展到现在云平台也做.</p><h5 id="其他编译器" tabindex="-1">其他编译器 <a class="header-anchor" href="#其他编译器" aria-label="Permalink to &quot;其他编译器&quot;">​</a></h5><p>基本一个芯片就有一个编译器, 毕竟不太复杂, 要么编译器支持你,要么你自己写一个编译器, 编译器在工作量和兼容更多的芯片之间做出选择, 厂家在学习成本/对客户吸引力和对编译器支持的力度做出选择, 开发者也会对学习成本和芯片价格做出选择.三方是互相影响的</p><h3 id="其他语言" tabindex="-1">其他语言 <a class="header-anchor" href="#其他语言" aria-label="Permalink to &quot;其他语言&quot;">​</a></h3><h4 id="micropython" tabindex="-1">micropython <a class="header-anchor" href="#micropython" aria-label="Permalink to &quot;micropython&quot;">​</a></h4><ul><li>支持部分芯片的部分功能</li></ul><h4 id="tinygo" tabindex="-1">tinygo <a class="header-anchor" href="#tinygo" aria-label="Permalink to &quot;tinygo&quot;">​</a></h4><ul><li>支持部分芯片的部分功能</li></ul><h4 id="nodemcu-lua" tabindex="-1">nodemcu(lua) <a class="header-anchor" href="#nodemcu-lua" aria-label="Permalink to &quot;nodemcu(lua)&quot;">​</a></h4><ul><li>好像是专门为了esp系列出的一套系统</li></ul><h1 id="c-c-编译过程发展史" tabindex="-1">C/C++编译过程发展史 <a class="header-anchor" href="#c-c-编译过程发展史" aria-label="Permalink to &quot;C/C++编译过程发展史&quot;">​</a></h1><h2 id="c-c-与-gcc-g" tabindex="-1">c/c++ 与 gcc/g++ <a class="header-anchor" href="#c-c-与-gcc-g" aria-label="Permalink to &quot;c/c++ 与  gcc/g++&quot;">​</a></h2><p><strong>gcc是GCC中的GUN C Compiler（C 编译器）</strong></p><p><strong>g++是GCC中的GUN C++ Compiler（C++编译器）</strong></p><p>gcc和g++的主要区别：</p><ol><li>对于 .c和.cpp文件，gcc分别当做c和cpp文件编译（cpp的语法规则比c的更强一些）；</li><li>对于 .c和.cpp文件，g++则统一当做cpp文件编译。</li><li>对于windwos平台, 有2个方案: vs 和 MinGW</li><li>CodeBlocks, CodeLite,Kate,Eclipse CDT4 是一个IDE, 对标是vsIDE</li></ol><h2 id="makefile的出现" tabindex="-1">makefile的出现 <a class="header-anchor" href="#makefile的出现" aria-label="Permalink to &quot;makefile的出现&quot;">​</a></h2><ul><li>但是当你的程序包含很多个源文件时，用gcc命令逐个去编译时，你就很容易混乱而且工作量大</li><li>所以出现了make工具make工具可以看成是一个智能的批处理工具，它本身并没有编译和链接的功能，而是用类似于批处理的方式—通过调用makefile文件中用户指定的命令来进行编译和链接的。</li><li>于此同时于make一起出现的还有</li></ul><h2 id="cmake的出现" tabindex="-1">cmake的出现 <a class="header-anchor" href="#cmake的出现" aria-label="Permalink to &quot;cmake的出现&quot;">​</a></h2><ul><li><p>makefile在一些简单的工程完全可以人工手下，但是当工程非常大的时候，手写makefile也是非常麻烦的，如果换了个平台makefile又要重新修改。</p></li><li><p>这时候就出现了Cmake这个工具，cmake就可以更加简单的生成makefile文件给上面那个make用。</p></li><li><p>当然cmake还有其他功能，就是可以跨平台生成对应平台能用的makefile，你不用再自己去修改了。</p></li><li><p>可是cmake根据什么生成makefile呢？它又要根据一个叫CMakeLists.txt文件（学名：组态档）去生成makefile。</p></li></ul><h2 id="与make-cmake-同时出现的解决方案有" tabindex="-1">与make-cmake 同时出现的解决方案有 <a class="header-anchor" href="#与make-cmake-同时出现的解决方案有" aria-label="Permalink to &quot;与make-cmake 同时出现的解决方案有&quot;">​</a></h2><ul><li>ninja, NMake</li></ul><h2 id="cmake-几乎支持所有的其他编译脚本" tabindex="-1">cmake 几乎支持所有的其他编译脚本: <a class="header-anchor" href="#cmake-几乎支持所有的其他编译脚本" aria-label="Permalink to &quot;cmake 几乎支持所有的其他编译脚本:&quot;">​</a></h2><ul><li>Visual Studio 16 2019 = Generates Visual Studio 2019 project files. Use -A option to specify architecture. Visual Studio 15 2017 [arch] = Generates Visual Studio 2017 project files. Optional [arch] can be &quot;Win64&quot; or &quot;ARM&quot;. Visual Studio 14 2015 [arch] = Generates Visual Studio 2015 project files. Optional [arch] can be &quot;Win64&quot; or &quot;ARM&quot;. Visual Studio 12 2013 [arch] = Generates Visual Studio 2013 project files. Optional [arch] can be &quot;Win64&quot; or &quot;ARM&quot;. Visual Studio 11 2012 [arch] = Generates Visual Studio 2012 project files. Optional [arch] can be &quot;Win64&quot; or &quot;ARM&quot;. Visual Studio 10 2010 [arch] = Generates Visual Studio 2010 project files. Optional [arch] can be &quot;Win64&quot; or &quot;IA64&quot;. Visual Studio 9 2008 [arch] = Generates Visual Studio 2008 project files. Optional [arch] can be &quot;Win64&quot; or &quot;IA64&quot;. Borland Makefiles = Generates Borland makefiles. NMake Makefiles = Generates NMake makefiles. NMake Makefiles JOM = Generates JOM makefiles. MSYS Makefiles = Generates MSYS makefiles. MinGW Makefiles = Generates a make file for use with mingw32-make. Unix Makefiles = Generates standard UNIX makefiles. Green Hills MULTI = Generates Green Hills MULTI files (experimental, work-in-progress). Ninja = Generates build.ninja files. Watcom WMake = Generates Watcom WMake makefiles. CodeBlocks - MinGW Makefiles = Generates CodeBlocks project files. CodeBlocks - NMake Makefiles = Generates CodeBlocks project files. CodeBlocks - NMake Makefiles JOM = Generates CodeBlocks project files. CodeBlocks - Ninja = Generates CodeBlocks project files. CodeBlocks - Unix Makefiles = Generates CodeBlocks project files. CodeLite - MinGW Makefiles = Generates CodeLite project files. CodeLite - NMake Makefiles = Generates CodeLite project files. CodeLite - Ninja = Generates CodeLite project files. CodeLite - Unix Makefiles = Generates CodeLite project files. Sublime Text 2 - MinGW Makefiles = Generates Sublime Text 2 project files. Sublime Text 2 - NMake Makefiles = Generates Sublime Text 2 project files. Sublime Text 2 - Ninja = Generates Sublime Text 2 project files. Sublime Text 2 - Unix Makefiles = Generates Sublime Text 2 project files. Kate - MinGW Makefiles = Generates Kate project files. Kate - NMake Makefiles = Generates Kate project files. Kate - Ninja = Generates Kate project files. Kate - Unix Makefiles = Generates Kate project files. Eclipse CDT4 - NMake Makefiles = Generates Eclipse CDT 4.0 project files. Eclipse CDT4 - MinGW Makefiles = Generates Eclipse CDT 4.0 project files. Eclipse CDT4 - Ninja = Generates Eclipse CDT 4.0 project files. Eclipse CDT4 - Unix Makefiles= Generates Eclipse CDT 4.0 project files.</li></ul><h2 id="qmake-是模仿cmake-的一个东西-但是仅支持make" tabindex="-1">qmake 是模仿cmake 的一个东西, 但是仅支持make <a class="header-anchor" href="#qmake-是模仿cmake-的一个东西-但是仅支持make" aria-label="Permalink to &quot;qmake 是模仿cmake 的一个东西, 但是仅支持make&quot;">​</a></h2><p>一般情况下我们在源码的同级目录下创建build文件夹</p><h1 id="qmake-跨平台编译" tabindex="-1">QMake 跨平台编译 <a class="header-anchor" href="#qmake-跨平台编译" aria-label="Permalink to &quot;QMake 跨平台编译&quot;">​</a></h1><h2 id="windows" tabindex="-1">Windows <a class="header-anchor" href="#windows" aria-label="Permalink to &quot;Windows&quot;">​</a></h2><p>在 mingw730_64/mingw730_32/msvc2017/msvc2017_64 选一个</p><h3 id="以-mingw730-64-为例" tabindex="-1">以 mingw730_64 为例: <a class="header-anchor" href="#以-mingw730-64-为例" aria-label="Permalink to &quot;以  mingw730_64 为例:&quot;">​</a></h3><p>将以下exe的目录加入环境变量(如果多个 加成临时的环境变量)</p><p>C:\\Qt\\Qt5.12.9\\Tools\\mingw730_64\\bin\\mingw32-make.exe</p><p>C:\\Qt\\Qt5.12.9\\5.12.9\\mingw73_64\\bin\\qmake.exe</p><h3 id="切换到源码目录" tabindex="-1">切换到源码目录 <a class="header-anchor" href="#切换到源码目录" aria-label="Permalink to &quot;切换到源码目录&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>cd E:\\PMSoft\\NewSrc\\trunk\\Tools\\qt_cross\\qmake_demo\\hello_build</span></span></code></pre></div><h3 id="qmake生成cmake的文件" tabindex="-1">qmake生成cmake的文件 <a class="header-anchor" href="#qmake生成cmake的文件" aria-label="Permalink to &quot;qmake生成cmake的文件&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>qmake ../hello/hello.pro</span></span></code></pre></div><h3 id="生成exe" tabindex="-1">生成exe <a class="header-anchor" href="#生成exe" aria-label="Permalink to &quot;生成exe&quot;">​</a></h3><h4 id="使用mingw32-make" tabindex="-1">使用mingw32-make <a class="header-anchor" href="#使用mingw32-make" aria-label="Permalink to &quot;使用mingw32-make&quot;">​</a></h4><p>release:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>mingw32-make</span></span></code></pre></div><p>debug:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>mingw32-make -f Makefile.Debug</span></span></code></pre></div><h2 id="ubuntu" tabindex="-1">Ubuntu <a class="header-anchor" href="#ubuntu" aria-label="Permalink to &quot;Ubuntu&quot;">​</a></h2><p>目前都是64位的系统 以gcc_64为例</p><p>/qt安装目录/gcc_64/lib</p><h3 id="永久添加环境变量" tabindex="-1">永久添加环境变量 <a class="header-anchor" href="#永久添加环境变量" aria-label="Permalink to &quot;永久添加环境变量&quot;">​</a></h3><p>打开文件 ~ 表示当前用户</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>vi ~/.bashrc</span></span></code></pre></div><p>添加环境变量</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>export PATH=$PATH:~/Qt/5.15.2/gcc_64/bin:~/Qt/Tools/CMake/bin</span></span></code></pre></div><p>生效文件</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>source ~/.bashrc</span></span></code></pre></div><p>确认成功</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>qmake -v</span></span></code></pre></div><h3 id="跳转到build目录" tabindex="-1">跳转到build目录 <a class="header-anchor" href="#跳转到build目录" aria-label="Permalink to &quot;跳转到build目录&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>cd ~/qt_src/qt_cross/qmake_demo/hello_build</span></span></code></pre></div><h3 id="生成cmake文件" tabindex="-1">生成cmake文件 <a class="header-anchor" href="#生成cmake文件" aria-label="Permalink to &quot;生成cmake文件&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>qmake ../hello/hello.pro</span></span></code></pre></div><h3 id="编译-j4-启动几个cpu进行编译" tabindex="-1">编译 -j4 启动几个cpu进行编译 <a class="header-anchor" href="#编译-j4-启动几个cpu进行编译" aria-label="Permalink to &quot;编译 -j4 启动几个cpu进行编译&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>make clean;</span></span>
<span class="line"><span>make -j4</span></span></code></pre></div><h1 id="cmake-跨平台编译" tabindex="-1">CMake 跨平台编译 <a class="header-anchor" href="#cmake-跨平台编译" aria-label="Permalink to &quot;CMake 跨平台编译&quot;">​</a></h1><h2 id="编译流程" tabindex="-1">编译流程 <a class="header-anchor" href="#编译流程" aria-label="Permalink to &quot;编译流程&quot;">​</a></h2><h3 id="用cmake-生成-makefile" tabindex="-1">用CMake 生成 Makefile <a class="header-anchor" href="#用cmake-生成-makefile" aria-label="Permalink to &quot;用CMake 生成 Makefile&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>cmake -DCMAKE_BUILD_TYPE=Debug -DCMAKE_DEPENDS_USE_COMPILER=FALSE -G &quot;CodeBlocks - MinGW Makefiles&quot;  ../</span></span></code></pre></div><p>或者简化为</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>cmake &quot;-GCodeBlocks - MinGW Makefiles&quot;  ../</span></span></code></pre></div><p>解释pwd为当前目录</p><ul><li><p>cmake会在pwd 生成makefile文件供make使用</p></li><li><p>会根据 <code>../</code> 为CMakeLists.txt所在的目录</p><ul><li><p>CMakeLists.txt 中有包含哪些文件, 怎么编译的信息</p></li><li><p>各种配置 如MinGW目录 QT_Creator 放在了 CMakeLists.txt.user 中, 里面是各种环境变量</p></li><li><p>Clion全部放在了CMakeLists.txt</p></li></ul></li><li><p>-D</p><ul><li>里面有很多编译设置 , 编译出来放在CMakeCache.txt</li></ul></li><li><p>-G</p><ul><li><code>-GCodeBlocks - MinGW Makefiles</code> 指MinGW的文件 <ul><li>因为有空格的原因 可以写为: <code>-G &quot;CodeBlocks - MinGW Makefiles&quot;</code></li></ul></li><li>CodeBlocks 是一个IDE, 同理有 CodeLite, Sublime Text 2,Kate, Eclipse CDT4, Ninja,Borland,Visual Studio 等等</li></ul></li></ul><h3 id="使用make编译" tabindex="-1">使用make编译 <a class="header-anchor" href="#使用make编译" aria-label="Permalink to &quot;使用make编译&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>make(linux)  or mingw32-make(windows)</span></span></code></pre></div><h2 id="windows实例" tabindex="-1">windows实例: <a class="header-anchor" href="#windows实例" aria-label="Permalink to &quot;windows实例:&quot;">​</a></h2><p>在hello源码目录同级建立hello_build文件夹</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>cd hello_build</span></span></code></pre></div><p>用CMake 生成 Makefile</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>cmake -DCMAKE_BUILD_TYPE=Debug -DCMAKE_DEPENDS_USE_COMPILER=FALSE -G &quot;CodeBlocks - MinGW Makefiles&quot;  ../hello</span></span></code></pre></div><p>make build exe</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>cmake --build . --target all -- -j 3</span></span></code></pre></div><p>or</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>mingw32-make</span></span></code></pre></div><h2 id="linux实例" tabindex="-1">linux实例: <a class="header-anchor" href="#linux实例" aria-label="Permalink to &quot;linux实例:&quot;">​</a></h2><p>在hello源码目录同级建立hello_build文件夹</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>mkdir hello_build</span></span>
<span class="line"><span>cd hello_build</span></span></code></pre></div><p>用CMake 生成 Makefile</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>cmake -DCMAKE_BUILD_TYPE=Debug -DCMAKE_DEPENDS_USE_COMPILER=FALSE -G &quot;CodeBlocks - Unix Makefiles&quot;  ../hello</span></span></code></pre></div><p>make build exe</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>cmake --build . --target all -- -j 3</span></span></code></pre></div><p>or</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>make</span></span></code></pre></div><h1 id="cmake和qmake对比" tabindex="-1">CMake和QMake对比 <a class="header-anchor" href="#cmake和qmake对比" aria-label="Permalink to &quot;CMake和QMake对比&quot;">​</a></h1><table tabindex="0"><thead><tr><th></th><th>CMAKE</th><th>QMAKE</th></tr></thead><tbody><tr><td>支持</td><td>qt6.0默认</td><td>qt5.0默认</td></tr><tr><td>跨平台</td><td>ok</td><td>ok</td></tr><tr><td>导入VS</td><td>麻烦,每次更新CMake都要重新导入</td><td>简单,每次更新CMake都要重新导入</td></tr><tr><td>导入Clion</td><td>简单</td><td>不支持</td></tr><tr><td>QTCreator</td><td>ok, 单要特定格式</td><td>ok</td></tr><tr><td>第三方控件</td><td>ok</td><td>没办法</td></tr></tbody></table><h1 id="ide的选择" tabindex="-1">IDE的选择 <a class="header-anchor" href="#ide的选择" aria-label="Permalink to &quot;IDE的选择&quot;">​</a></h1><table tabindex="0"><thead><tr><th>ToolChain</th><th>QT Creator</th><th>vs</th><th>clion</th></tr></thead><tbody><tr><td>CMake</td><td><strong>cmake</strong>/qMake</td><td><strong>cmake</strong>/vs_qmake</td><td>cmake</td></tr><tr><td>编译器</td><td>vs/MinGW</td><td>ninja</td><td>vs/MinGW</td></tr></tbody></table><h2 id="推荐直接只用qtcreator-新建cmake工程" tabindex="-1">推荐直接只用QTCreator 新建CMake工程 <a class="header-anchor" href="#推荐直接只用qtcreator-新建cmake工程" aria-label="Permalink to &quot;推荐直接只用QTCreator 新建CMake工程&quot;">​</a></h2><p>qt6放弃qmake转向cmake</p><h2 id="使用clion进行开发" tabindex="-1">使用Clion进行开发 <a class="header-anchor" href="#使用clion进行开发" aria-label="Permalink to &quot;使用Clion进行开发&quot;">​</a></h2><p>打开setting</p><ul><li>修改ToolChains 为QT</li><li>修改build dicrectory: cmake</li></ul><h2 id="使用visual-studio" tabindex="-1">使用Visual Studio <a class="header-anchor" href="#使用visual-studio" aria-label="Permalink to &quot;使用Visual Studio&quot;">​</a></h2><p>vs2019及以上才支持默认采用Ninja</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>cmake -G &quot;Ninja&quot;  -DCMAKE_BUILD_TYPE:STRING=&quot;Debug&quot; -DCMAKE_MAKE_PROGRAM=&quot;ninja.exe&quot; ../</span></span></code></pre></div><p>cmakelist.txt中添加</p><p>修改CMakeSettings.json</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>      &quot;variables&quot;: [</span></span>
<span class="line"><span>        {</span></span>
<span class="line"><span>          &quot;name&quot;: &quot;Qt5_DIR&quot;,</span></span>
<span class="line"><span>          &quot;value&quot;: &quot;C:/Qt/Qt5.12.9/5.12.9/msvc2017_64/lib/cmake/Qt5&quot;,</span></span>
<span class="line"><span>          &quot;type&quot;: &quot;PATH&quot;</span></span>
<span class="line"><span>        },</span></span>
<span class="line"><span>        {</span></span>
<span class="line"><span>          &quot;name&quot;: &quot;Qt5Core_DIR&quot;,</span></span>
<span class="line"><span>          &quot;value&quot;: &quot;C:/Qt/Qt5.12.9/5.12.9/msvc2017_64/lib/cmake/Qt5Core&quot;,</span></span>
<span class="line"><span>          &quot;type&quot;: &quot;PATH&quot;</span></span>
<span class="line"><span>        },</span></span>
<span class="line"><span>        {</span></span>
<span class="line"><span>          &quot;name&quot;: &quot;Qt5Gui_DIR&quot;,</span></span>
<span class="line"><span>          &quot;value&quot;: &quot;C:/Qt/Qt5.12.9/5.12.9/msvc2017_64/lib/cmake/Qt5Gui&quot;,</span></span>
<span class="line"><span>          &quot;type&quot;: &quot;PATH&quot;</span></span>
<span class="line"><span>        },</span></span>
<span class="line"><span>        {</span></span>
<span class="line"><span>          &quot;name&quot;: &quot;Qt5Widgets_DIR&quot;,</span></span>
<span class="line"><span>          &quot;value&quot;: &quot;C:/Qt/Qt5.12.9/5.12.9/msvc2017_64/lib/cmake/Qt5Widgets&quot;,</span></span>
<span class="line"><span>          &quot;type&quot;: &quot;PATH&quot;</span></span>
<span class="line"><span>        },</span></span>
<span class="line"><span>        {</span></span>
<span class="line"><span>          &quot;name&quot;: &quot;QT_DIR&quot;,</span></span>
<span class="line"><span>          &quot;value&quot;: &quot;C:/Qt/Qt5.12.9/5.12.9/msvc2017_64/lib/cmake&quot;,</span></span>
<span class="line"><span>          &quot;type&quot;: &quot;PATH&quot;</span></span>
<span class="line"><span>        }</span></span></code></pre></div>`,162)]))}const k=e(s,[["render",n]]);export{u as __pageData,k as default};
